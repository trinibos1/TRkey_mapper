<!DOCTYPE html>
<html lang="en" class="h-full bg-zinc-800">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trkey Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <style>
        /* Custom scrollbar styling for Tailwind's custom-scrollbar class */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #3f3f46; /* zinc-700 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #ef4444; /* red-500 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #dc2626; /* red-600 */
        }
        /* Ensure html, body and root take full height and remove default margins/padding */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #root { /* Apply to html as well */
            height: 100%;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body class="font-inter h-full">
    <div id="root"></div>

    <script type="text/babel">
        // All React component code consolidated here

        // Explicitly get React and ReactDOM from the window object
        const React = window.React;
        const ReactDOM = window.ReactDOM;

        // NEW: Define minimum and maximum grid sizes
        const MIN_GRID_SIZE = 2;
        const MAX_GRID_SIZE = 5;
        const DEFAULT_GRID_SIZE = 3; // Default 3x3 grid

        // Constants with ALL shortcuts from the PDF, adapted for CircuitPython Keycode names
        const presets = {
            "STANDARD_KEYS": [
                { combo: "A", description: "A" },
                { combo: "B", description: "B" },
                { combo: "C", description: "C" },
                { combo: "D", description: "D" },
                { combo: "E", description: "E" },
                { combo: "F", description: "F" },
                { combo: "G", description: "G" },
                { combo: "H", description: "H" },
                { combo: "I", description: "I" },
                { combo: "J", description: "J" },
                { combo: "K", description: "K" },
                { combo: "L", description: "L" },
                { combo: "M", description: "M" },
                { combo: "N", description: "N" },
                { combo: "O", description: "O" },
                { combo: "P", description: "P" },
                { combo: "Q", description: "Q" },
                { combo: "R", description: "R" },
                { combo: "S", description: "S" },
                { combo: "T", description: "T" },
                { combo: "U", description: "U" },
                { combo: "V", description: "V" },
                { combo: "W", description: "W" },
                { combo: "X", description: "X" },
                { combo: "Y", description: "Y" },
                { combo: "Z", description: "Z" },
                { combo: "ONE", description: "1" },
                { combo: "TWO", description: "2" },
                { combo: "THREE", description: "3" },
                { combo: "FOUR", description: "4" },
                { combo: "FIVE", description: "5" },
                { combo: "SIX", description: "6" },
                { combo: "SEVEN", description: "7" },
                { combo: "EIGHT", description: "8" },
                { combo: "NINE", description: "9" },
                { combo: "ZERO", description: "0" },
                { combo: "ENTER", description: "Enter" },
                { combo: "ESCAPE", description: "Esc" },
                { combo: "TAB", description: "Tab" },
                { combo: "SPACEBAR", description: "Space" },
                { combo: "BACKSPACE", description: "Bksp" },
                { combo: "DELETE", description: "Del" },
                { combo: "CAPS_LOCK", description: "Caps" },
                { combo: "F1", description: "F1" },
                { combo: "F2", description: "F2" },
                { combo: "F3", description: "F3" },
                { combo: "F4", description: "F4" },
                { combo: "F5", description: "F5" },
                { combo: "F6", description: "F6" },
                { combo: "F7", description: "F7" },
                { combo: "F8", description: "F8" },
                { combo: "F9", description: "F9" },
                { combo: "F10", description: "F10" },
                { combo: "F11", description: "F11" },
                { combo: "F12", description: "F12" },
                { combo: "PRINT_SCREEN", description: "PrtSc" },
                { combo: "SCROLL_LOCK", description: "ScrLk" },
                { combo: "PAUSE", description: "Pause" },
                { combo: "INSERT", description: "Ins" },
                { combo: "HOME", description: "Home" },
                { combo: "PAGE_UP", description: "PgUp" },
                { combo: "PAGE_DOWN", description: "PgDn" },
                { combo: "END", description: "End" },
                { combo: "RIGHT_ARROW", description: "R Arrow" },
                { combo: "LEFT_ARROW", description: "L Arrow" },
                { combo: "DOWN_ARROW", description: "Dn Arrow" },
                { combo: "UP_ARROW", description: "Up Arrow" },
                { combo: "KEYPAD_NUMLOCK", description: "NumLk" },
                { combo: "KEYPAD_SLASH", description: "Kp /" },
                { combo: "KEYPAD_ASTERISK", description: "Kp *" },
                { combo: "KEYPAD_MINUS", description: "Kp -" },
                { combo: "KEYPAD_PLUS", description: "Kp +" },
                { combo: "KEYPAD_ENTER", description: "Kp Ent" },
                { combo: "KEYPAD_ONE", description: "Kp 1" },
                { combo: "KEYPAD_TWO", description: "Kp 2" },
                { combo: "KEYPAD_THREE", description: "Kp 3" },
                { combo: "KEYPAD_FOUR", description: "Kp 4" },
                { combo: "KEYPAD_FIVE", description: "Kp 5" },
                { combo: "KEYPAD_SIX", description: "Kp 6" },
                { combo: "KEYPAD_SEVEN", description: "Kp 7" },
                { combo: "KEYPAD_EIGHT", description: "Kp 8" },
                { combo: "KEYPAD_NINE", description: "Kp 9" },
                { combo: "KEYPAD_ZERO", description: "Kp 0" },
                { combo: "KEYPAD_PERIOD", description: "Kp ." },
                { combo: "NON_US_SLASH", description: "Non-US /" },
                { combo: "APPLICATION", description: "App Key" },
                { combo: "COMMA", description: "Comma" },
                { combo: "PERIOD", description: "Period" },
                { combo: "GRAVE_ACCENT", description: "Grave" },
                { combo: "MINUS", description: "Minus" },
                { combo: "EQUAL", description: "Equal" },
                { combo: "LEFT_BRACKET", description: "L Brkt" },
                { combo: "RIGHT_BRACKET", description: "R Brkt" },
                { combo: "BACKSLASH", description: "Bcksl" },
                { combo: "SEMICOLON", description: "Semicln" },
                { combo: "QUOTE", description: "Quote" },
                { combo: "SLASH", description: "Slash" },
            ],
            "MODIFIER_KEYS": [
                { combo: "LEFT_CONTROL", description: "L Ctrl" },
                { combo: "LEFT_SHIFT", description: "L Shift" },
                { combo: "LEFT_ALT", description: "L Alt" },
                { combo: "LEFT_GUI", description: "L GUI" },
                { combo: "RIGHT_CONTROL", description: "R Ctrl" },
                { combo: "RIGHT_SHIFT", description: "R Shift" },
                { combo: "RIGHT_ALT", description: "R Alt" },
                { combo: "RIGHT_GUI", description: "R GUI" },
            ],
            "COMBINATION_SHORTCUTS": [
                { combo: "CONTROL_C", description: "Copy" },
                { combo: "CONTROL_V", description: "Paste" },
                { combo: "CONTROL_X", description: "Cut" },
                { combo: "CONTROL_Z", description: "Undo" },
                { combo: "CONTROL_Y", description: "Redo" },
                { combo: "CONTROL_S", description: "Save" },
                { combo: "ALT_TAB", description: "App Switch" },
                { combo: "GUI_D", description: "Desktop" },
                { combo: "CONTROL_SHIFT_ESCAPE", description: "TaskMgr" },
                { combo: "CONTROL_A", description: "Sel All" },
                { combo: "CONTROL_F", description: "Find" },
                { combo: "CONTROL_P", description: "Print" },
                { combo: "CONTROL_L", description: "Align L" },
                { combo: "CONTROL_R", description: "Align R" },
                { combo: "CONTROL_E", description: "Align C" },
                { combo: "CONTROL_D", description: "Dupe" },
                { combo: "CONTROL_G", description: "Group" },
                { combo: "CONTROL_U", description: "Ungrp" },
                { combo: "CONTROL_K", description: "Link" },
                { combo: "CONTROL_H", description: "Replace" },
                { combo: "CONTROL_B", description: "Bold" },
                { combo: "CONTROL_I", description: "Italic" },
                { combo: "CONTROL_U", description: "Undrl" },
                { combo: "ALT_ENTER", description: "Fullscreen" },
                { combo: "SHIFT_ARROW", description: "Nudge" },
                { combo: "SHIFT_SPACEBAR", description: "Cycle Units" },
                { combo: "CONTROL_SPACEBAR", description: "Suggest" },
                { combo: "CONTROL_FORWARD_SLASH", description: "Comment" },
                { combo: "ALT_UP_ARROW", description: "Line Up" },
                { combo: "ALT_DOWN_ARROW", description: "Line Dn" },
                { combo: "SHIFT_ALT_DOWN_ARROW", description: "Copy Line" },
                { combo: "CONTROL_SHIFT_K", description: "Del Line" },
                { combo: "CONTROL_ENTER", description: "Ins Line B" },
                { combo: "CONTROL_SHIFT_ENTER", description: "Ins Line A" },
                { combo: "CONTROL_SHIFT_RIGHT_BRACKET", description: "Jmp Brkt" },
                { combo: "CONTROL_TAB", description: "Next Edit" },
                { combo: "CONTROL_SHIFT_TAB", description: "Prev Edit" },
                { combo: "CONTROL_W", description: "Close Tab" },
                { combo: "CONTROL_ALT_T", description: "Terminal" },
                { combo: "CONTROL_SHIFT_P", description: "Cmd Pal" },
                { combo: "CONTROL_GRAVE_ACCENT", description: "Term Tog" },
                { combo: "CONTROL_B", description: "Side Tog" },
                { combo: "CONTROL_J", description: "Panel Tog" },
                { combo: "CONTROL_SHIFT_E", description: "Explorer" },
                { combo: "CONTROL_SHIFT_F", description: "File Srch" },
                { combo: "CONTROL_SHIFT_G", description: "Git" },
                { combo: "CONTROL_SHIFT_D", description: "Debug" },
                { combo: "CONTROL_SHIFT_X", description: "Extens" },
                { combo: "CONTROL_SHIFT_S", description: "Save As" },
                { combo: "CONTROL_N", description: "New File" },
                { combo: "CONTROL_O", description: "Open File" },
                { combo: "CONTROL_Q", description: "Quit App" },
                { combo: "CONTROL_ALT_DELETE", description: "Force Quit" },
                { combo: "CONTROL_SHIFT", description: "Walk" },
                { combo: "CONTROL_F1", description: "Switch Class" },
                { combo: "ALT_V", description: "View Chg" },
                { combo: "ALT_M", description: "Minimap" },
                { combo: "CONTROL_R", description: "Reload" },
                { combo: "ALT_F4", description: "Close Win" },
                { combo: "CONTROL_Y", description: "Chat" },
                { combo: "CONTROL_G", description: "Gun View" },
                { combo: "CONTROL_T", description: "Anchor" },
                { combo: "CONTROL_SHIFT_M", description: "Model" },
                { combo: "CONTROL_ALT_T", description: "Terrain" },
                { combo: "CONTROL_SHIFT_R", description: "Run" },
                { combo: "CONTROL_SHIFT_T", description: "Test" },
                { combo: "CONTROL_SHIFT_F", description: "Search All" },
                { combo: "CONTROL_SHIFT_D", description: "Download" },
                { combo: "CONTROL_SHIFT_C", description: "Output" },
                { combo: "CONTROL_SHIFT_H", description: "View Exp" },
                { combo: "CONTROL_SHIFT_X", description: "Props" },
                { combo: "CONTROL_SHIFT_E", description: "Toolbox" },
                { combo: "ALT_LEFT_BRACKET", description: "Lyr Back" },
                { combo: "ALT_RIGHT_BRACKET", description: "Lyr Fwd" },
                { combo: "ALT_SHIFT_E", description: "Export" },
            ],
            "MEDIA_CONTROLS": [
                { combo: "VOLUME_INCREMENT", description: "Vol Up" },
                { combo: "VOLUME_DECREMENT", description: "Vol Down" },
                { combo: "MUTE", description: "Mute" },
                { combo: "PLAY_PAUSE", description: "Play/Pse" },
                { combo: "SCAN_PREVIOUS_TRACK", description: "Prev Trk" },
                { combo: "SCAN_NEXT_TRACK", description: "Next Trk" },
            ],
            "MOUSE_ACTIONS": [
                { combo: "MOUSE_BUTTON_1", description: "L Click" },
                { combo: "MOUSE_BUTTON_2", description: "R Click" },
                { combo: "MOUSE_BUTTON_3", description: "M Click" },
                { combo: "MOUSE_WHEEL_UP", description: "Scroll Up" },
                { combo: "MOUSE_WHEEL_DOWN", description: "Scroll Dn" },
                { combo: "ALT_DRAG", description: "Alt Drag" },
                { combo: "SHIFT_DRAG", description: "Shft Drag" },
                { combo: "CONTROL_CLICK", description: "Ctrl Click" },
                { combo: "CONTROL_MIDDLE_CLICK", description: "Ctrl M Click" },
                { combo: "SHIFT_LEFT_CLICK", description: "Shft L Click" },
                { combo: "SHIFT_RIGHT_CLICK", description: "Shft R Click" },
                { combo: "DOUBLE_CLICK", description: "Dbl Click" },
            ],
            "MACROS": [
                { combo: "MACRO_1", description: "Macro 1" },
                { combo: "MACRO_2", description: "Macro 2" },
                { combo: "MACRO_3", description: "Macro 3" },
            ],
            "LAYER_SWITCHING": [ // New category for layer switching keycodes
                { combo: "TO", description: "Permanent to Layer X" },
                { combo: "MO", description: "Momentary to Layer X" },
                { combo: "TT", description: "Toggle Layer X" },
                { combo: "DF", description: "Set Default Layer X" },
            ],
            "SYSTEM_CONTROLS": [
                { combo: "POWER", description: "Power" },
                { combo: "SLEEP", description: "Sleep" },
                { combo: "WAKE", description: "Wake" },
            ],
            "MINECRAFT_SPECIFIC": [
                { combo: "W_KEY", description: "Fwd" },
                { combo: "A_KEY", description: "Left" },
                { combo: "S_KEY", description: "Bck" },
                { combo: "D_KEY", description: "Right" },
                { combo: "DOUBLE_SPACE", description: "Fly Tog" },
                { combo: "NUMBER_HOVER", description: "Hotbar" },
                { combo: "F3_D", description: "Clr Chat" },
                { combo: "F3_N", description: "GM Swch" },
                { combo: "F3_C", description: "Crash" },
                { combo: "F3_A", description: "Reload" },
            ],
            "KICAD_SPECIFIC": [
                { combo: "CONTROL_SCROLL", description: "Zoom" },
                { combo: "ALT_ONE", description: "Lyr Vw 1" },
                { combo: "ALT_TWO", description: "Lyr Vw 2" },
                { combo: "ALT_THREE", description: "Lyr Vw 3" },
                { combo: "ALT_FOUR", description: "Lyr Vw 4" },
                { combo: "ALT_FIVE", description: "Lyr w 5" },
            ],
            "FUSION360_SPECIFIC": [
                { combo: "SHIFT_SCROLL", description: "Pan" },
            ],
        };

        const MIN_LAYERS = 1;
        const MAX_LAYERS = 10;
        const DEFAULT_LAYERS = 2; // Default number of layers for initial load if no profile exists

        // Helper function to create an empty layer object
        // Now accepts gridSize to correctly size the arrays
        const createEmptyLayer = (index, currentGridSize) => ({
            name: `Layer ${index}`,
            labels: Array(currentGridSize * currentGridSize).fill(''),
            keys: Array(currentGridSize * currentGridSize).fill(null),
            macros: [] // Macros are technically global to the app but stored on Layer 0 in JSON
        });

        // Helper function to create a default physical layout based on currentGridSize
        // Now accepts gridSize to correctly size the layout
        const createDefaultPhysicalLayout = (currentGridSize) => {
            const layout = [];
            for (let i = 0; i < currentGridSize * currentGridSize; i++) {
                layout.push({ index: i, row: Math.floor(i / currentGridSize), col: i % currentGridSize });
            }
            return layout;
        };


        // Modal component (formerly from src/components/Modal.js)
        const Modal = ({ show, title, message, onClose, autoClose }) => {
            const { useEffect } = React;
            useEffect(() => {
                if (show && autoClose) {
                    const timer = setTimeout(() => {
                        onClose();
                    }, 2000); // Auto-close after 2 seconds
                    return () => clearTimeout(timer);
                }
            }, [show, autoClose, onClose]);

            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{title}</h3>
                        {message && <p className="mb-4">{message}</p>}
                        <div className="flex justify-end">
                            <button
                                onClick={onClose}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                OK
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Confirmation Modal (formerly from src/components/ConfirmationModal.js)
        const ConfirmationModal = ({ show, title, message, onConfirm, onCancel }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{title}</h3>
                        {message && <p className="mb-4">{message}</p>}
                        <div className="flex justify-end space-x-4">
                            <button
                                onClick={onCancel}
                                className="bg-zinc-600 hover:bg-zinc-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={onConfirm}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Confirm
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // NEW: LayerAssignmentModal for TO(x), MO(x), TT(x), DF(x)
        const LayerAssignmentModal = ({ show, type, maxLayer, onAssign, onCancel, setShowAppModal, setAppModalContent }) => {
            const { useState, useEffect, useRef } = React;
            const [layerNumberInput, setLayerNumberInput] = useState('');
            const inputRef = useRef(null);

            useEffect(() => {
                if (show) {
                    setLayerNumberInput(''); // Clear input on show
                    // Focus the input field when the modal appears
                    const timeoutId = setTimeout(() => {
                        if (inputRef.current) {
                            inputRef.current.focus();
                        }
                    }, 10); // Small delay to ensure modal is rendered
                    return () => clearTimeout(timeoutId);
                }
            }, [show]);

            const handleAssignClick = () => {
                const num = parseInt(layerNumberInput, 10);
                if (!isNaN(num) && num >= 0 && num <= maxLayer) {
                    onAssign(type, num);
                } else {
                    // Use the app's modal system instead of alert()
                    if (setShowAppModal && setAppModalContent) {
                        setAppModalContent({
                            title: "Invalid Layer Number",
                            message: `Please enter a valid layer number between 0 and ${maxLayer}.`
                        });
                        setShowAppModal(true);
                    } else {
                        console.error(`Invalid layer number: Please enter a valid layer number between 0 and ${maxLayer}.`);
                    }
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleAssignClick();
                } else if (e.key === 'Escape') {
                    onCancel();
                }
            };

            if (!show) return null;

            let titleText = "";
            let descriptionText = "";
            switch (type) {
                case "TO":
                    titleText = "Assign Permanent Layer Switch (TO)";
                    descriptionText = "Enter the layer number to switch to permanently.";
                    break; // Added break
                case "MO":
                    titleText = "Assign Momentary Layer Switch (MO)";
                    descriptionText = "Enter the layer number to switch to while held.";
                    break; // Added break
                case "TT":
                    titleText = "Assign Toggle Layer (TT)";
                    descriptionText = "Enter the layer number to toggle on/off.";
                    break; // Added break
                case "DF":
                    titleText = "Assign Set Default Layer (DF)";
                    descriptionText = "Enter the layer number to set as the new default.";
                    break; // Added break
                default:
                    titleText = "Assign Layer Function";
                    descriptionText = "Enter the target layer number.";
                    break; // Added break for consistency
            }

            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{titleText}</h3>
                        <p className="mb-4 text-zinc-300">{descriptionText}</p>
                        {/* Added id for accessibility and auto-fill */}
                        <input
                            id="layer-number-input"
                            ref={inputRef}
                            type="number"
                            min="0"
                            max={maxLayer}
                            value={layerNumberInput}
                            onChange={(e) => setLayerNumberInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            className="w-full p-3 mb-6 rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:border-red-500 focus:ring-1 focus:ring-red-500 transition-all duration-200"
                            placeholder={`Layer (0-${maxLayer})`}
                        />
                        <div className="flex justify-end space-x-4">
                            <button
                                onClick={onCancel}
                                className="bg-zinc-600 hover:bg-zinc-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={handleAssignClick}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Assign
                            </button>
                        </div>
                    </div>
                </div>
            );
        };


        // Sidebar component (formerly from src/components/Sidebar.js)
        const Sidebar = ({ activeTab, setActiveTab }) => {
            const { useState, useEffect } = React; // Ensure React hooks are imported within component scope
            return (
                <div className="w-64 bg-zinc-900 p-6 flex flex-col border-r border-zinc-700 shadow-xl">
                    <div className="text-2xl font-bold text-red-500 mb-8">Trkey</div>
                    <nav className="flex-grow">
                        <ul className="space-y-4">
                            <li>
                                <a href="#" onClick={() => setActiveTab('keymap')} className={`flex items-center ${activeTab === 'keymap' ? 'text-red-300' : 'text-zinc-400'} hover:text-red-500 font-semibold text-lg transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path></svg>
                                    KEYMAP
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('layout')} className={`flex items-center ${activeTab === 'layout' ? 'text-red-300' : 'text-zinc-400'} hover:text-red-500 font-semibold text-lg transition-colors duration-200`}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M9 20l-5.447-2.723A1 1 0 013 16.382V5.618a1 1 0 011.553-.894L9 7m0 13l6-3m-6 3V7m6 10l4.447 2.223A1 1 0 0021 18.382V7.618a1 1 0 00-1.553-.894L15 10m0 0V7m0 10.382l-.618.309L12 21l-2.382-1.191L9 20m0-13l2.382 1.191L12 3l2.382 1.191L15 7m0 0V3m0 0l-5.447 2.723A1 1 0 009 5.618V16.382a1 1 0 001.553.894L15 13m0 0V7"/>
                                </svg>
                                    LAYOUT
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('macros')} className={`flex items-center ${activeTab === 'macros' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M12 6.293V4a1 1 0 00-1-1H5a1 1 0 00-1 1v10a1 1 0 001 1h6a1 1 0 001-1v-2.293l1.707 1.707a1 1 0 001.414-1.414l-4-4a1 1 0 00-1.414 0l-4 4a1 1 0 001.414 1.414L10 10.414V12a1 1 0 001 1h2a1 1 0 001-1V8.293l1.707 1.707a1 1 0 001.414-1.414l-4-4z"></path></svg>
                                    MACROS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('connect-load')} className={`flex items-center ${activeTab === 'connect-load' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4a2 1 0 012-2h6a2 1 0 012 2v14l-5-2.5L5 18V4z"></path></svg>
                                    CONNECT + LOAD
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('settings')} className={`flex items-center ${activeTab === 'settings' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 00-1 1v1a1 1 0 002 0V3a1 1 0 00-1-1zm4 4a1 1 0 011 1v1a1 1 0 01-2 0V7a1 1 0 011-1zM6 6a1 1 0 00-1 1v1a1 1 0 002 0V7a1 1 0 00-1-1zm0 8a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm8 0a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm-4 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zM2 10a1 1 0 001 1h1a1 1 0 000-2H3a1 1 0 00-1 1zm14 0a1 1 0 001 1h1a1 1 0 000-2h-1a1 1 0 00-1 1zM7 10a3 3 0 116 0 3 3 0 01-6 0z"></path></svg>
                                    SETTINGS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('keytester')} className={`flex items-center ${activeTab === 'keytester' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 002 0V3zM14 8a1 1 0 011 1v1a1 1 0 11-2 0V9a1 1 0 011-1zM6 8a1 1 0 00-1 1v1a1 1 0 002 0V9a1 1 0 00-1-1zm0 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm8 0a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm-4 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zM2 10a1 1 0 001 1h1a1 1 0 000-2H3a1 1 0 00-1 1zm14 0a1 1 0 001 1h1a1 1 0 000-2h-1a1 1 0 00-1 1zM7 10a3 3 0 116 0 3 3 0 01-6 0z"></path></svg>
                                    KEY TESTER
                                </a>
                            </li>
                        </ul>
                    </nav>
                </div>
            );
        };

        // KeymapGrid component (formerly from src/components/KeymapGrid.js)
        const KeymapGrid = ({ keymap, handleDrop, handleKeymapDragStart, handleDragEnd, clearKeymapCell, currentLayer, setCurrentLayer, selectedKeymapCell, handleKeymapCellClick, clearCurrentLayer, numLayers, physicalLayout, gridSize }) => {
            const { useState, useEffect } = React;
            // The keymap prop is now an array of layer objects, each with 'keys' and 'labels'
            const NUM_KEYS_IN_GRID = gridSize * gridSize; // Dynamically calculate
            const currentLayerData = keymap[currentLayer] || { keys: Array(NUM_KEYS_IN_GRID).fill(null), labels: Array(NUM_KEYS_IN_GRID).fill('') };

            // Helper to get the key/label for a specific flat index
            const getCellContent = (flatIndex) => {
                // Ensure flatIndex is within bounds for keymap data
                if (flatIndex < 0 || flatIndex >= currentLayerData.keys.length) {
                    return null;
                }

                const keyCombo = currentLayerData.keys[flatIndex];
                const keyLabel = currentLayerData.labels[flatIndex];
                
                if (keyCombo) {
                    // Try to parse special layer keycodes first
                    const layerKeyMatch = keyCombo.match(/^(TO|MO|TT|DF)\((\d+)\)$/);
                    if (layerKeyMatch) {
                        const type = layerKeyMatch[1];
                        const layerNum = layerKeyMatch[2];
                        let descriptionText = "";
                        switch (type) {
                            case "TO": descriptionText = "Permanent to Layer"; break;
                            case "MO": descriptionText = "Momentary to Layer"; break;
                            case "TT": descriptionText = "Toggle Layer"; break;
                            case "DF": descriptionText = "Set Default Layer"; break;
                            default: descriptionText = "Layer Action";
                        }
                        return { combo: `${type}(${layerNum})`, description: `${descriptionText} ${layerNum}` };
                    }

                    // For macros, use the macro name as description
                    if (keyCombo.startsWith("MACRO_")) {
                        const macroNum = keyCombo.split('_')[1];
                        // If you want to show the actual macro name, you'd need to pass the macros array here
                        return { combo: keyCombo, description: `Macro ${macroNum}` };
                    }
                    // Special handling for NO_OP
                    if (keyCombo === "NO_OP") {
                        return { combo: "NO_OP", description: "No Operation" };
                    }

                    // For standard keys and combinations, find the description from presets
                    let description = keyLabel; // Default to label if no specific preset description
                    for (const category in presets) {
                        // Skip LAYER_SWITCHING category as it's handled above
                        if (category === "LAYER_SWITCHING") continue;

                        const found = presets[category].find(p => p.combo === keyCombo);
                        if (found) {
                            description = found.description;
                            break;
                        }
                    }

                    return { combo: keyCombo, description: description };
                }
                return null;
            };

            const gridColsClass = `grid-cols-${gridSize}`; // Dynamically set grid columns using the prop

            return (
                <div className="flex flex-col items-center">
                    <div className="flex flex-wrap justify-center gap-2 mb-4"> {/* Use flex-wrap for responsiveness */}
                        {[...Array(numLayers)].map((_, index) => ( // Render buttons based on numLayers
                            <button
                                key={`layer-btn-${index}`}
                                onClick={() => setCurrentLayer(index)}
                                className={`px-4 py-2 rounded-lg font-semibold transition-colors duration-200
                                            ${currentLayer === index ? 'bg-red-600 text-white shadow-md' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}
                            >
                                Layer {index}
                            </button>
                        ))}
                        <button
                            onClick={clearCurrentLayer}
                            className="px-4 py-2 rounded-lg font-semibold bg-red-800 text-white hover:bg-red-700 transition-colors duration-200 shadow-md"
                            title="Clear all keys on the current layer"
                        >
                            Clear Current Layer
                        </button>
                    </div>
                    {/* Render keys based on physicalLayout */}
                    <div className={`grid ${gridColsClass} gap-4 mb-12 w-full max-w-2xl mx-auto`}> {/* Use gridColsClass and increased max-width */}
                        {/* Generate all possible grid cells first, then map physical layout onto them */}
                        {Array.from({ length: gridSize * gridSize }).map((_, globalGridIndex) => {
                            const row = Math.floor(globalGridIndex / gridSize);
                            const col = globalGridIndex % gridSize; /* FIX: Changed 'i' to 'globalGridIndex' */
                            
                            // Check if this global grid index corresponds to an active key in physicalLayout
                            const layoutItem = physicalLayout.find(item => item && item.row === row && item.col === col);
                            
                            const flatIndex = layoutItem ? layoutItem.index : null; // Get the flat index if it's an active key
                            const cellContent = flatIndex !== null ? getCellContent(flatIndex) : null;

                            // Determine if this is an active key cell or a placeholder
                            const isActiveKeyCell = flatIndex !== null;

                            return (
                                <div
                                    key={`grid-cell-${globalGridIndex}`} /* Unique key for each display cell */
                                    className={`relative rounded-xl p-4 h-32 flex flex-col items-center justify-center border-2 shadow-md
                                                ${isActiveKeyCell 
                                                    ? `bg-zinc-700 hover:border-red-500 transition-all duration-200 cursor-pointer ${selectedKeymapCell && selectedKeymapCell.index === flatIndex && selectedKeymapCell.layer === currentLayer ? 'border-blue-500 ring-2 ring-blue-500 bg-blue-900 bg-opacity-30' : 'border-zinc-600'}`
                                                    : 'bg-zinc-800 border-zinc-700'
                                                }`}
                                    onDragOver={(e) => { if (isActiveKeyCell) e.preventDefault(); }} /* Only allow drop on active keys */
                                    onDrop={(e) => { if (isActiveKeyCell) handleDrop(e, flatIndex); }} /* Pass flatIndex for active keys */
                                    draggable={isActiveKeyCell} /* Only draggable if it's an active key */
                                    onDragStart={(e) => { if (isActiveKeyCell) handleKeymapDragStart(e, cellContent, flatIndex); }}
                                    onDragEnd={handleDragEnd}
                                    onClick={() => { if (isActiveKeyCell) handleKeymapCellClick(flatIndex, currentLayer); }}
                                >
                                    {isActiveKeyCell ? (
                                        cellContent ? (
                                            <>
                                                <span className="text-2xl font-bold text-red-300">{cellContent.combo}</span>
                                                <span className="text-sm text-zinc-400 text-center mt-1">{cellContent.description}</span>
                                            </>
                                        ) : (
                                            <span className="text-zinc-500">Drag & Drop Here</span>
                                        )
                                    ) : (
                                        <span className="text-zinc-600 text-sm">Empty Slot</span>
                                    )}
                                    {isActiveKeyCell && cellContent && (
                                        <button
                                            onClick={(e) => { e.stopPropagation(); clearKeymapCell(flatIndex); }}
                                            className="absolute top-1 right-1 text-zinc-400 hover:text-red-500 text-sm p-1 rounded-full bg-zinc-600 hover:bg-zinc-500 transition-colors"
                                            title="Clear cell"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ShortcutPool component (formerly from src/components/ShortcutPool.js)
        const ShortcutPool = ({ shortcutPool, draggedShortcut, handleShortcutDragStart, handleDragEnd, selectedKeymapCell, handleShortcutClick }) => {
            const { useState, useEffect, useMemo } = React; // Added useMemo
            const [searchTerm, setSearchTerm] = useState('');
            // Initialize selectedCategory to the first key in shortcutPool
            const [selectedCategory, setSelectedCategory] = useState(Object.keys(shortcutPool)[0]);

            // Filter shortcuts based on selected category and search term
            const filteredShortcuts = useMemo(() => {
                if (!selectedCategory) return []; // No category selected yet

                const categoryShortcuts = shortcutPool[selectedCategory] || [];
                if (!searchTerm) return categoryShortcuts;

                const lowerCaseSearchTerm = searchTerm.toLowerCase();
                return categoryShortcuts.filter(shortcut =>
                    shortcut.combo.toLowerCase().includes(lowerCaseSearchTerm) ||
                    shortcut.description.toLowerCase().includes(lowerCaseSearchTerm)
                );
            }, [searchTerm, selectedCategory, shortcutPool]);

            return (
                <div className="flex flex-col md:flex-row w-full bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-hidden">
                    {/* Left Sidebar for Categories */}
                    <div className="w-full md:w-1/4 bg-zinc-900 p-4 custom-scrollbar overflow-y-auto border-r border-zinc-700">
                        <h3 className="text-xl font-semibold text-red-300 mb-4">Categories</h3>
                        <ul className="space-y-2">
                            {Object.keys(shortcutPool).map(category => (
                                <li key={category}>
                                    <button
                                        onClick={() => setSelectedCategory(category)}
                                        className={`w-full text-left px-4 py-2 rounded-lg transition-colors duration-200
                                                    ${selectedCategory === category ? 'bg-red-600 text-white font-bold' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}
                                    >
                                        {category}
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>

                    {/* Right Main Content Area for Search and Shortcuts */}
                    <div className="flex-1 flex flex-col p-4">
                        {/* Search Bar */}
                        <div className="relative w-full mb-6">
                            {/* Added id for accessibility and auto-fill */}
                            <input
                                id="shortcut-search-input"
                                type="text"
                                placeholder="Search shortcuts..."
                                className="w-full p-3 pl-10 rounded-xl bg-zinc-700 text-white border border-zinc-600 focus:border-red-500 focus:ring-1 focus:ring-red-500 transition-all duration-200"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-zinc-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd"></path></svg>
                        </div>

                        {/* Shortcuts Grid */}
                        <div className="flex-1 grid grid-cols-2 md:grid-cols-3 gap-4 custom-scrollbar overflow-y-auto pr-2">
                            {filteredShortcuts.length > 0 ? (
                                filteredShortcuts.map((shortcut, sIdx) => (
                                    <div
                                        key={`${selectedCategory}-${sIdx}`} // Ensure unique key
                                        className={`bg-zinc-600 rounded-lg p-3 flex flex-col items-center justify-center cursor-pointer text-center /* Changed cursor to pointer */
                                                    ${draggedShortcut === shortcut ? 'opacity-50 border-red-500 border-2' : 'border-2 border-zinc-600'}
                                                    ${selectedKeymapCell ? 'hover:bg-blue-700 hover:border-blue-400' : 'hover:bg-zinc-500 hover:border-red-400'} /* Conditional hover */
                                                    transition-all duration-200`}
                                        draggable
                                        onDragStart={(e) => handleShortcutDragStart(e, shortcut)}
                                        onDragEnd={handleDragEnd}
                                        onClick={() => handleShortcutClick(shortcut)} /* Added onClick */
                                    >
                                        <span className="font-medium text-lg">{shortcut.combo}</span>
                                        <span className="text-sm text-zinc-300">{shortcut.description}</span>
                                        {selectedKeymapCell && (
                                            <button
                                                onClick={(e) => { e.stopPropagation(); handleShortcutClick(shortcut); }}
                                                className="mt-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Assign
                                            </button>
                                        )}
                                    </div>
                                ))
                            ) : (
                                <p className="text-zinc-400 text-lg col-span-full text-center">No shortcuts found in "{selectedCategory}" matching "{searchTerm}".</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // MacroManagement component (formerly from src/components/MacroManagement.js)
        const MacroManagement = ({ macros, addMacro, editMacro, deleteMacro }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">MACRO MANAGEMENT</h1>
                    <button
                        onClick={addMacro}
                        className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold mb-8"
                    >
                        Add New Macro
                    </button>

                    {macros.length === 0 ? (
                        <p className="text-zinc-400 text-lg">No macros defined yet. Click "Add New Macro" to create one.</p>
                    ) : (
                        <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                            <h2 className="text-2xl font-bold text-red-300 mb-4">Defined Macros</h2>
                            <ul className="space-y-4">
                                {macros.map(macro => (
                                    <li key={macro.id} className="bg-zinc-600 rounded-lg p-4 flex flex-col sm:flex-row justify-between items-start sm:items-center shadow-md border border-zinc-500">
                                        <div>
                                            <p className="text-xl font-semibold text-white">{macro.name}</p>
                                            <p className="text-zinc-300 text-sm break-all">Sequence: "{macro.sequence}"</p>
                                        </div>
                                        <div className="flex space-x-3 mt-3 sm:mt-0">
                                            <button
                                                onClick={() => editMacro(macro.id)}
                                                className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Edit
                                            </button>
                                            <button
                                                onClick={() => deleteMacro(macro.id)}
                                                className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Delete
                                            </button>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
            );
        };

        // ConnectLoad component (formerly SaveLoad)
        const ConnectLoad = ({ saveProfile, loadProfile, exportKeymap, uploadToDevice, isConnected, handleConnectPico, handleGetFile, handleDeleteFile, logs, clearLogs, showLogDropdown, toggleLogDropdown, webSerialSupported, isLoadingDeviceConfig, handleListFiles, handleDownloadLastGet, lastDownloadedFileContent }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full p-8">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">CONNECT & LOAD</h1>
                    <div className="flex flex-col space-y-4 w-full max-w-md">
                        <button
                            onClick={saveProfile}
                            className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Save Profile to Browser
                        </button>
                        <button
                            onClick={loadProfile}
                            className="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Load Profile from Browser
                        </button>
                        <button
                            onClick={exportKeymap}
                            className="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Export Configuration as layers.json
                        </button>
                        <div className="bg-zinc-700 rounded-xl p-4 text-zinc-300 text-center text-sm border border-zinc-600">
                            To upload to Pico manually: Save the exported `layers.json` file, then drag and drop it onto your `CIRCUITPY` drive.
                        </div>
                        <h2 className="text-2xl font-bold text-red-300 mt-8 mb-4">Device Operations (Web Serial)</h2>
                        {!webSerialSupported && (
                            <p className="text-red-300 text-sm mb-4 text-center">
                                *Web Serial API is required for direct device interaction and is best supported in Chromium-based browsers (e.g., Chrome, Edge).
                            </p>
                        )}
                        {!isConnected ? (
                             <button
                                onClick={handleConnectPico}
                                className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold
                                            ${webSerialSupported ? 'bg-purple-600 hover:bg-purple-700' : 'bg-gray-500 cursor-not-allowed'}`}
                                disabled={!webSerialSupported || isLoadingDeviceConfig}
                            >
                                {isLoadingDeviceConfig ? 'Connecting...' : (webSerialSupported ? 'Connect to Device' : 'Web Serial Not Supported')}
                            </button>
                        ) : (
                            <>
                                <p className="text-green-400 text-center text-lg font-semibold">Connected to Pico!</p>
                                {/* Removed the "Device handshake complete." message */}
                                <button
                                    onClick={uploadToDevice}
                                    className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold bg-purple-600 hover:bg-purple-700`}
                                    disabled={!isConnected}
                                >
                                    Upload layers.json to Device
                                </button>
                                <button
                                    onClick={() => handleGetFile("layers.json")}
                                    className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold bg-purple-600 hover:bg-purple-700`}
                                    disabled={!isConnected}
                                >
                                    Check layers.json on Device
                                </button>
                                <button
                                    onClick={() => handleDeleteFile("layers.json")}
                                    className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold bg-purple-600 hover:bg-purple-700`}
                                    disabled={!isConnected}
                                >
                                    Delete layers.json on Device
                                </button>
                                <hr className="border-zinc-600 my-4" /> {/* Separator */}
                                <button
                                    onClick={handleListFiles}
                                    className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold bg-teal-600 hover:bg-teal-700`}
                                    disabled={!isConnected}
                                >
                                    List Files on Device
                                </button>
                                <button
                                    onClick={handleDownloadLastGet}
                                    className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold
                                                ${lastDownloadedFileContent ? 'bg-orange-600 hover:bg-orange-700' : 'bg-gray-500 cursor-not-allowed'}`}
                                    disabled={!lastDownloadedFileContent}
                                >
                                    Download Last GET
                                </button>
                            </>
                        )}

                        {/* Log Display Dropdown */}
                        <div className="mt-8 w-full">
                            <button
                                onClick={toggleLogDropdown}
                                className="w-full bg-zinc-600 hover:bg-zinc-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold flex justify-between items-center"
                            >
                                Show Device Log
                                <svg className={`w-5 h-5 transition-transform duration-200 ${showLogDropdown ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            {showLogDropdown && (
                                <div className="bg-zinc-700 rounded-xl p-4 mt-4 shadow-lg border border-zinc-600">
                                    {/* Added id for accessibility and auto-fill */}
                                    <textarea
                                        id="device-log-textarea"
                                        readOnly
                                        value={logs.join('\n')}
                                        className="w-full h-48 bg-zinc-800 border border-zinc-600 rounded-md p-3 text-white font-mono text-sm resize-y custom-scrollbar"
                                        placeholder="Device log messages will appear here..."
                                    ></textarea>
                                    <button
                                        onClick={clearLogs}
                                        className="mt-3 bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200 text-sm font-semibold w-full"
                                    >
                                        Clear Log
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // NEW: Component to display the physical layout JSON
        const PhysicalLayoutViewer = ({ physicalLayout }) => {
            const { useState, useEffect } = React;
            const [layoutJson, setLayoutJson] = useState('');

            useEffect(() => {
                try {
                    setLayoutJson(JSON.stringify(physicalLayout, null, 2));
                } catch (e) {
                    setLayoutJson("Error displaying layout JSON.");
                }
            }, [physicalLayout]);

            return (
                <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 mt-8">
                    <h2 className="text-2xl font-bold text-red-300 mb-4">Current Physical Layout (from Application State)</h2>
                    <p className="text-zinc-400 mb-2 text-sm">This shows the layout currently applied to the UI. To change it, modify the grid above or import a full JSON configuration in the Settings tab that includes a "physical_layout" array.</p>
                    {/* Added id for accessibility and auto-fill */}
                    <textarea
                        id="physical-layout-textarea"
                        readOnly
                        className="w-full h-64 bg-zinc-800 border border-zinc-600 rounded-md p-4 text-white font-mono text-sm resize-y custom-scrollbar"
                        value={layoutJson}
                    ></textarea>
                </div>
            );
        };

        // Settings component (formerly from src/components/Settings.js)
        const Settings = ({ jsonInput, setJsonInput, loadConfigFromJson, numLayers, setNumLayers, physicalLayout }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full p-8"> {/* Added padding here */}
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">SETTINGS</h1>
                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                        <h2 className="text-2xl font-bold text-red-300 mb-4">Layer Configuration</h2>
                        <div className="flex items-center justify-between mb-6">
                            <label htmlFor="num-layers" className="text-lg text-zinc-200 mr-4">Number of Layers:</label>
                            {/* Added id for accessibility and auto-fill */}
                            <input
                                type="number"
                                id="num-layers"
                                value={numLayers}
                                onChange={(e) => {
                                    const value = parseInt(e.target.value);
                                    if (!isNaN(value)) {
                                        setNumLayers(Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, value)));
                                    }
                                }}
                                min={MIN_LAYERS}
                                max={MAX_LAYERS} 
                                className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-24 text-white text-center"
                            />
                        </div>

                        <h2 className="2xl font-bold text-red-300 mb-4">Import JSON Configuration</h2>
                        {/* Added id for accessibility and auto-fill */}
                        <textarea
                            id="json-config-input"
                            className="w-full h-64 bg-zinc-800 border border-zinc-600 rounded-md p-4 text-white font-mono text-sm resize-y"
                            placeholder="Paste your full Trkey configuration JSON here, including 'physical_layout' and 'layers'..."
                            value={jsonInput}
                            onChange={(e) => setJsonInput(e.target.value)}
                        ></textarea>
                        <button
                            onClick={() => loadConfigFromJson(jsonInput)}
                            className="mt-4 bg-teal-600 hover:bg-teal-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full"
                        >
                            Load JSON
                        </button>
                    </div>
                    {/* Add the PhysicalLayoutViewer component here */}
                    <PhysicalLayoutViewer physicalLayout={physicalLayout} />
                </div>
            );
        };

        // KeyTester component (formerly from src/components/KeyTester.js)
        const KeyTester = ({ activeTab }) => {
            const { useState, useEffect } = React;
            const [pressedKeys, setPressedKeys] = useState([]);
            const [modifierState, setModifierState] = useState({
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                metaKey: false, // Windows key or Command key on Mac
            });

            useEffect(() => {
                if (activeTab === 'keytester') {
                    const handleKeyDown = (e) => {
                        e.preventDefault(); // Prevent default browser actions for keys
                        setPressedKeys(prev => {
                            const newKey = { key: e.key, code: e.code, timestamp: Date.now() };
                            // Only add if not already present to avoid duplicates for held keys
                            if (!prev.some(k => k.code === e.code)) {
                                return [...prev, newKey];
                            }
                            return prev;
                        });
                        setModifierState({
                            ctrlKey: e.ctrlKey,
                            shiftKey: e.shiftKey,
                            altKey: e.altKey,
                            metaKey: e.metaKey,
                        });
                    };

                    const handleKeyUp = (e) => {
                        e.preventDefault();
                        setPressedKeys(prev => prev.filter(k => k.code !== e.code));
                        setModifierState({
                            ctrlKey: e.ctrlKey,
                            shiftKey: e.shiftKey,
                            altKey: e.altKey,
                            metaKey: e.metaKey,
                        });
                    };

                    window.addEventListener('keydown', handleKeyDown);
                    window.addEventListener('keyup', handleKeyUp);

                    return () => {
                        window.removeEventListener('keydown', handleKeyDown);
                        window.removeEventListener('keyup', handleKeyUp);
                    };
                } else {
                    setPressedKeys([]);
                    setModifierState({
                        ctrlKey: false,
                        shiftKey: false,
                        altKey: false,
                        metaKey: false,
                    });
                }
            }, [activeTab]);

            const clearPressedKeys = () => {
                setPressedKeys([]);
                setModifierState({
                    ctrlKey: false,
                    shiftKey: false,
                    altKey: false,
                    metaKey: false,
                });
            };

            return (
                <div className="flex flex-col items-center w-full p-8">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">KEY TESTER</h1>
                    <p className="text-zinc-300 mb-6 text-lg text-center">Press any key on your keyboard to see its details and active modifiers.</p>

                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 min-h-[250px] flex flex-col items-center">
                        <div className="flex justify-center space-x-4 mb-6 w-full">
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.ctrlKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Ctrl</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.shiftKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Shift</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.altKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Alt</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.metaKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Meta (Win/Cmd)</span>
                        </div>

                        <div className="flex-1 flex flex-wrap items-center justify-center gap-4 w-full">
                            {pressedKeys.length === 0 ? (
                                <p className="text-zinc-400 text-xl">No keys pressed...</p>
                            ) : (
                                pressedKeys.map((keyInfo, index) => (
                                    <div
                                        key={keyInfo.code + '-' + keyInfo.timestamp}
                                        className="bg-zinc-600 rounded-lg p-4 shadow-md border border-zinc-500 flex flex-col items-center justify-center min-w-[120px] transform transition-transform duration-100 hover:scale-105"
                                    >
                                        <span className="text-xl font-bold text-red-300">{keyInfo.key === ' ' ? 'Space' : keyInfo.key === '' ? 'Unknown' : keyInfo.key}</span>
                                        <span className="text-sm text-zinc-400 mt-1">{keyInfo.code}</span>
                                    </div>
                                ))
                            )}
                        </div>
                        <button
                            onClick={clearPressedKeys}
                            className="mt-6 bg-red-600 hover:bg-red-700 px-6 py-2 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Clear Pressed Keys
                        </button>
                    </div>
                </div>
            );
        };

        {/* Renamed MappingPage to LayoutPage */}
        const LayoutPage = ({ gridSize, setGridSize, physicalLayout, setPhysicalLayout, keymap, setKeymap, exportKeymap, uploadToDevice, isConnected, handleConnectPico, webSerialSupported, isHandshakeComplete }) => {
            const { useState, useEffect } = React;

            // Effect to update physicalLayout and keymap structure when gridSize changes
            useEffect(() => {
                const numExpectedKeys = gridSize * gridSize;

                // Only regenerate the default physicalLayout if the existing one is not perfectly sized for the current grid
                // This prevents `toggleKeyActive` from being undone by this effect.
                const currentValidPhysicalLayout = physicalLayout.filter(item => 
                    item && typeof item.index === 'number' && item.row < gridSize && item.col < gridSize
                );

                if (currentValidPhysicalLayout.length !== numExpectedKeys || currentValidPhysicalLayout.some(item => !item)) {
                    setPhysicalLayout(createDefaultPhysicalLayout(gridSize));
                }

                // Ensure keymap layers are correctly sized based on the current gridSize,
                // preserving existing key assignments where possible.
                setKeymap(prevKeymap => prevKeymap.map((layer, lIdx) => {
                    const newKeys = Array(numExpectedKeys).fill(null);
                    const newLabels = Array(numExpectedKeys).fill('');
                    
                    // Determine which physical layout to use for reference: 
                    // a valid current one, or a newly generated default one.
                    const referenceLayout = (currentValidPhysicalLayout.length === numExpectedKeys && !currentValidPhysicalLayout.some(item => !item)) 
                                            ? currentValidPhysicalLayout 
                                            : createDefaultPhysicalLayout(gridSize);

                    referenceLayout.forEach(layoutItem => {
                        if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < (layer.keys ? layer.keys.length : 0) && layoutItem.index < numExpectedKeys) {
                            newKeys[layoutItem.index] = layer.keys[layoutItem.index];
                            newLabels[layoutItem.index] = layer.labels[layoutItem.index];
                        }
                    });
                    return { ...layer, keys: newKeys, labels: newLabels };
                }));

            }, [gridSize]); // Removed physicalLayout from dependencies here.


            const toggleKeyActive = (row, col) => {
                const newPhysicalLayout = [...physicalLayout];
                const flatIndex = row * gridSize + col;

                // Check if a key at this logical position (row, col) already exists in physicalLayout
                // We need to check based on row/col because flatIndex might change if grid size changes,
                // but row/col is the stable position in the visual grid.
                const existingKeyIndexInArray = newPhysicalLayout.findIndex(item => item && item.row === row && item.col === col);

                if (existingKeyIndexInArray !== -1) {
                    // Key exists, so make it inactive (remove it from the array)
                    newPhysicalLayout.splice(existingKeyIndexInArray, 1);
                } else {
                    // Key does not exist, so add it. Assign the current flatIndex as its index.
                    newPhysicalLayout.push({ index: flatIndex, row: row, col: col });
                }

                // Re-sort the layout by index to maintain consistency for how it's consumed by KeymapGrid
                newPhysicalLayout.sort((a, b) => a.index - b.index);
                setPhysicalLayout(newPhysicalLayout);

                // Also, clear the corresponding keymap entry for this specific flat index if the physical key is removed
                if (existingKeyIndexInArray !== -1) {
                    setKeymap(prevKeymap => prevKeymap.map(layer => {
                        const newKeys = [...layer.keys];
                        const newLabels = [...layer.labels];
                        // Only clear if the flatIndex is valid for the current keymap size
                        if (flatIndex < newKeys.length) { 
                            newKeys[flatIndex] = null;
                            newLabels[flatIndex] = '';
                        }
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }));
                }
            };

            const gridColsClass = `grid-cols-${gridSize}`;

            return (
                <div className="flex flex-col items-center w-full p-8">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">KEYBOARD LAYOUT CONFIGURATION</h1>
                    <p className="text-zinc-300 mb-6 text-lg text-center">Define the physical layout of your macropad. Click on cells to toggle them between active key positions and empty slots. Active keys (red background) will be included in your physical layout. Empty slots (darker background) will not be part of your Trkey's layout.</p>
                    
                    {/* Grid Size Configuration - Moved from Settings */}
                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 mb-8">
                        <h2 className="text-2xl font-bold text-red-300 mb-4">Grid Dimensions</h2>
                        <div className="flex items-center justify-between mb-6">
                            <label htmlFor="grid-size" className="text-lg text-zinc-200 mr-4">Grid Size (2x2 to 5x5):</label>
                            <input
                                type="number"
                                id="grid-size"
                                value={gridSize}
                                onChange={(e) => {
                                    const value = parseInt(e.target.value);
                                    if (!isNaN(value)) {
                                        setGridSize(Math.max(MIN_GRID_SIZE, Math.min(MAX_GRID_SIZE, value)));
                                    }
                                }}
                                min={MIN_GRID_SIZE}
                                max={MAX_GRID_SIZE}
                                className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-24 text-white text-center"
                            />
                        </div>
                    </div>

                    <div className={`grid ${gridColsClass} gap-4 w-full max-w-2xl mx-auto mb-8`}>
                        {Array.from({ length: gridSize * gridSize }).map((_, i) => {
                            const row = Math.floor(i / gridSize);
                            const col = i % gridSize;
                            // Check if this cell is part of the active physical layout
                            const isActive = physicalLayout.some(item => item && item.row === row && item.col === col);

                            return (
                                <div
                                    key={`layout-cell-${row}-${col}`}
                                    className={`relative h-32 flex flex-col items-center justify-center rounded-xl p-4 shadow-md border-2
                                                ${isActive ? 'bg-red-800 border-red-600 text-white cursor-pointer hover:bg-red-700' : 'bg-zinc-800 border-zinc-700 text-zinc-500 cursor-pointer hover:bg-zinc-700'}
                                                transition-all duration-200`}
                                    onClick={() => toggleKeyActive(row, col)}
                                >
                                    <span className="text-3xl font-bold">{i}</span> {/* Display flat index */}
                                    <span className="text-sm">({row}, {col})</span> {/* Display row, col */}
                                    {isActive ? (
                                        <span className="absolute bottom-2 text-xs font-semibold text-red-200">ACTIVE KEY</span>
                                    ) : (
                                        <span className="absolute bottom-2 text-xs font-semibold text-zinc-400">EMPTY SLOT</span>
                                    )}
                                </div>
                            );
                        })}
                    </div>

                    <div className="w-full max-w-2xl text-center text-zinc-400 text-sm mb-8">
                        The numbers (0, 1, 2...) displayed in each cell represent its **logical index** within the grid. When a cell is an **ACTIVE KEY**, this index will correspond to its position in the `physical_layout` array and the `keys` and `labels` arrays of each layer in the generated JSON.
                    </div>

                    {/* New Buttons for Upload/Download */}
                    <div className="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 w-full max-w-2xl">
                        <button
                            onClick={exportKeymap}
                            className="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full sm:w-1/2"
                        >
                            Download Layout JSON
                        </button>
                        {!isConnected ? (
                             <button
                                onClick={handleConnectPico}
                                className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full sm:w-1/2"
                                title={!webSerialSupported ? "Web Serial API not supported by your browser." : "Connect to your macropad via Web Serial."}
                                disabled={!webSerialSupported}
                            >
                                {webSerialSupported ? 'Connect to Macropad' : 'Web Serial Not Supported'}
                            </button>
                        ) : (
                            <button
                                onClick={uploadToDevice}
                                className={`px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold bg-red-600 hover:bg-red-700`}
                                disabled={!isConnected}
                            >
                                Upload Layout to Macropad
                            </button>
                        )}
                    </div>
                     {!webSerialSupported && (
                        <p className="text-red-300 text-sm mt-4 text-center">
                            *Web Serial API is required for direct device interaction and is best supported in Chromium-based browsers (e.g., Chrome, Chrome Beta, Edge).
                        </p>
                    )}

                    {/* Add the PhysicalLayoutViewer component here */}
                    <PhysicalLayoutViewer physicalLayout={physicalLayout} />
                </div>
            );
        };


        // Main App component (formerly from src/App.js)
        function App() {
            const { useState, useEffect, useCallback, useRef } = React;

            // Web Serial state
            const [port, setPort] = useState(null);
            const readerRef = useRef(null); // Changed to useRef
            const writerRef = useRef(null); // Changed to useRef
            const [isConnected, setIsConnected] = useState(false);
            const encoder = new TextEncoder();
            const decoder = new TextDecoder(); 
            const incomingAppReadBuffer = useRef(''); 
            const timeoutIdRef = useRef(null); 
            const lastSentCommandForEchoCheck = useRef(null); 

            // Log state
            const [logs, setLogs] = useState([]);
            const [showLogDropdown, setShowLogDropdown] = useState(false);
            const [isLoadingDeviceConfig, setIsLoadingDeviceConfig] = useState(false); 
            // New state to store the content of the last downloaded file
            const [lastDownloadedFileContent, setLastDownloadedFileContent] = useState(null);


            const addLog = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogs(prevLogs => [`[${timestamp}] [${type.toUpperCase()}] ${message}`, ...prevLogs].slice(0, 50)); 
            };

            const clearLogs = () => {
                setLogs([]);
            };

            const toggleLogDropdown = () => {
                setShowLogDropdown(prev => !prev);
            };

            // Define a comprehensive function to clean a line of terminal junk
            const cleanReceivedLine = (line) => {
                let cleaned = line;

                // 1. Remove OSC (Operating System Command) sequences (e.g., window title)
                // These start with ESC ] and typically end with BEL (\x07) or ST (ESC \).
                // This regex attempts to match ESC ] followed by any character (non-greedy)
                // until it finds a BEL, ST, or another ESC character (which might indicate a malformed sequence end)
                // or the end of the line.
                cleaned = cleaned.replace(/\x1B\](?:.*?)(?:\x07|\x1B\\|\x1B|$)/g, '');

                // 2. Remove CSI (Control Sequence Introducer) sequences (e.g., color codes)
                // These start with ESC [ and end with a letter.
                cleaned = cleaned.replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '');
                
                // 3. Remove any remaining bare ESC characters.
                // This catches any ESCs that might have been part of an unrecognised or malformed sequence
                // after the previous replacements.
                cleaned = cleaned.replace(/\x1B/g, '');

                // 4. Remove miscellaneous non-printable ASCII control characters (C0 control codes)
                //    excluding newline (\n) and carriage return (\r) which are fundamental for line handling.
                cleaned = cleaned.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, ''); 

                // Finally, trim leading/trailing whitespace characters
                return cleaned.trim();
            };
            
            // Helper for APP component to send JSON commands (for future use, if device implements JSON API)
            const appSendJsonCommand = useCallback(async (commandObj) => { 
                const activeWriter = writerRef.current; 

                if (!activeWriter) { 
                    addLog(`App: Operation aborted. Reason: Writer unavailable.`, 'error');
                    throw new Error(`Writer not available.`);
                }
                try {
                    const data = JSON.stringify(commandObj) + "\n";
                    lastSentCommandForEchoCheck.current = data.trim(); 
                    await activeWriter.write(encoder.encode(data)); 
                    addLog(`App: Sent JSON command: ${JSON.stringify(commandObj)}`, 'sent');
                } catch (error) {
                    addLog(`App: Failed to send command: ${error.message}`, 'error');
                    throw error;
                }
            }, []);

            // Helper for APP component to send raw string commands (e.g., LIST, PUT, GET, DEL)
            const appSendRawCommand = useCallback(async (commandString) => {
                const activeWriter = writerRef.current;
                if (!activeWriter) {
                    addLog(`App: Operation aborted. Reason: Writer unavailable.`, 'error');
                    throw new Error(`Writer not available.`);
                }
                try {
                    const data = commandString.trim() + "\n"; // Ensure newline for command
                    lastSentCommandForEchoCheck.current = data.trim();
                    await activeWriter.write(encoder.encode(data));
                    addLog(`App: Sent raw command: "${commandString.trim()}"`, 'sent');
                } catch (error) {
                    addLog(`App: Failed to send raw command: ${error.message}`, 'error');
                    throw error;
                }
            }, []);

            // New: Function to read a single line acknowledgement
            const appReadAcknowledgement = useCallback(async (expectedResponse = null, timeoutMs = 15000) => {
                const activeReader = readerRef.current;
                if (!activeReader) {
                    addLog(`App: Operation aborted. Reason: Reader unavailable.`, 'error');
                    throw new Error(`Reader not available.`);
                }

                let buffer = incomingAppReadBuffer.current;
                incomingAppReadBuffer.current = ''; // Clear buffer at the start of a new read

                const timeoutPromise = new Promise((_, reject) => {
                    timeoutIdRef.current = setTimeout(() => {
                        if (activeReader && activeReader.locked) {
                            activeReader.cancel();
                        }
                        reject(new Error(`Acknowledgement read timed out after ${timeoutMs}ms. Expected: "${expectedResponse || 'any non-empty line'}"`));
                    }, timeoutMs);
                });

                const readPromise = new Promise(async (resolve, reject) => {
                    try {
                        while (true) {
                            const { value, done } = await activeReader.read();
                            if (done) {
                                addLog("App: Reader stream closed during acknowledgement read.", "info");
                                reject(new Error("Reader stream closed prematurely."));
                                break;
                            }
                            if (value) {
                                buffer += decoder.decode(value, { stream: true });

                                let newlineIndex;
                                while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                                    let line = buffer.substring(0, newlineIndex);
                                    buffer = buffer.substring(newlineIndex + 1);

                                    const originalLineBeforeCleaning = line;
                                    line = cleanReceivedLine(line);

                                    addLog(`DEBUG (Ack): Raw line: "${originalLineBeforeCleaning.replace(/\x1B/g, '\\x1B')}" -> Cleaned: "${line}"`, 'debug');

                                    if (line === "iles:") { // CircuitPython LIST quirk
                                        addLog(`App: Correcting "iles:" to "Files:" (CircuitPython LIST quirk).`, 'debug');
                                        line = "Files:";
                                    }

                                    // Skip echoing of sent commands
                                    if (lastSentCommandForEchoCheck.current && line === lastSentCommandForEchoCheck.current) {
                                        addLog(`App: Skipping echoed command: "${line}"`, 'debug');
                                        lastSentCommandForEchoCheck.current = null;
                                        continue;
                                    }

                                    // If we are looking for a specific response and found it, or if any non-empty line is valid.
                                    if (line.length > 0 && (expectedResponse === null || line === expectedResponse)) {
                                        clearTimeout(timeoutIdRef.current);
                                        incomingAppReadBuffer.current = buffer; // Store remaining buffer
                                        addLog(`App: Received expected acknowledgement: "${line}"`, 'response');
                                        resolve(line);
                                        return;
                                    }
                                    // If we received an unexpected line, log it but keep looking unless timeout
                                    if (line.length > 0 && expectedResponse !== null && line !== expectedResponse) {
                                        addLog(`App: Received unexpected line during acknowledgement wait: "${line}" (still looking for "${expectedResponse}")`, 'warn');
                                    }
                                }
                                incomingAppReadBuffer.current = buffer; // Store current buffer if no newline found
                            }
                        }
                    } catch (error) {
                        clearTimeout(timeoutIdRef.current);
                        addLog(`App: Error during acknowledgement read: ${error.message}`, "error");
                        reject(error);
                    }
                });

                return Promise.race([readPromise, timeoutPromise]);
            }, []);

            // New: Function to read multi-line file content until <EOF>
            const appReadFileContent = useCallback(async (timeoutMs = 60000) => {
                const activeReader = readerRef.current;
                if (!activeReader) {
                    addLog(`App: Operation aborted. Reason: Reader unavailable.`, 'error');
                    throw new Error(`Reader not available.`);
                }

                let buffer = incomingAppReadBuffer.current;
                incomingAppReadBuffer.current = ''; // Clear buffer at the start of a new read
                let fileContentBuffer = '';

                const timeoutPromise = new Promise((_, reject) => {
                    timeoutIdRef.current = setTimeout(() => {
                        if (activeReader && activeReader.locked) {
                            activeReader.cancel();
                        }
                        reject(new Error(`File content read timed out after ${timeoutMs}ms. (Missing <EOF>)`));
                    }, timeoutMs);
                });

                const readPromise = new Promise(async (resolve, reject) => {
                    try {
                        while (true) {
                            const { value, done } = await activeReader.read();
                            if (done) {
                                addLog("App: Reader stream closed during file content read.", "info");
                                reject(new Error("Reader stream closed prematurely."));
                                break;
                            }
                            if (value) {
                                buffer += decoder.decode(value, { stream: true });

                                const eofIndex = buffer.indexOf("<EOF>\n");
                                if (eofIndex !== -1) {
                                    fileContentBuffer += buffer.substring(0, eofIndex);
                                    const remainingBuffer = buffer.substring(eofIndex + "<EOF>\n".length);
                                    
                                    clearTimeout(timeoutIdRef.current);
                                    incomingAppReadBuffer.current = remainingBuffer; // Store buffer after EOF
                                    
                                    const cleanedContent = cleanReceivedLine(fileContentBuffer); // Clean the whole file content
                                    addLog(`App: Received full file content (up to <EOF>), length: ${cleanedContent.length}.`, 'response');
                                    resolve(cleanedContent);
                                    return;
                                }

                                // If <EOF> not yet found, append whole buffer to fileContentBuffer
                                fileContentBuffer += buffer;
                                buffer = ''; // Clear buffer as content moved to fileContentBuffer
                            }
                        }
                    } catch (error) {
                        clearTimeout(timeoutIdRef.current);
                        addLog(`App: Error during file content read: ${error.message}`, "error");
                        reject(error);
                    }
                });

                return Promise.race([readPromise, timeoutPromise]);
            }, []);


            // Web Serial Utility Functions
            const handleConnectPico = async () => {
                 try {
                    addLog("Attempting to connect to Pico...", "info");
                    
                    // Request permission to access a serial port.
                    const selectedPort = await navigator.serial.requestPort(); 

                    setIsLoadingDeviceConfig(true); 
                    setModalContent({
                        title: "Connecting...",
                        message: "Opening port and initiating communication...", 
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false 
                    });
                    setShowModal(true); 

                    // Open the serial port.
                    // Changed baudRate to 115200 for better compatibility
                    await selectedPort.open({ baudRate: 115200 });

                    // Get a writable stream and a readable stream from the port.
                    writerRef.current = selectedPort.writable.getWriter();
                    readerRef.current = selectedPort.readable.getReader();
                    setPort(selectedPort);

                    // Update connection state for UI.
                    setIsConnected(true); 
                    
                    addLog("Successfully connected to Pico! Proceeding to load configuration...", "success");

                    // Small delay to give Pico firmware time to boot and UART to settle.
                    await new Promise(r => setTimeout(r, 1000)); 

                    // --- SIMPLIFIED CONNECTION LOGIC (NO EXPLICIT HANDSHAKE) ---
                    // Directly proceed with requesting layers.json after a brief delay
                    try {
                        addLog("Requesting layers.json from Pico...", "info");
                        await appSendRawCommand("GET layers.json"); 
                        
                        // Use appReadFileContent to get the full file content
                        const fileContent = await appReadFileContent(60000); // 60-second timeout for the file content
                        
                        setLastDownloadedFileContent(fileContent); // Store for potential download

                        if (fileContent.length > 0) { 
                            loadConfigFromJson(fileContent, "fromDevice"); // Pass original string for loadConfigFromJson
                            setModalContent(prev => ({ ...prev, title: "Load Successful", message: "Connected and loaded configuration from device!", autoClose: true }));
                            addLog("Configuration loaded automatically from device.", "success");
                        } else {
                            // If GET returned <EOF> immediately without content, assume file not found/empty
                            addLog("layers.json not found or is empty on device. Starting with default configuration.", "warn");
                            loadConfigFromJson(JSON.stringify({
                                grid_size: DEFAULT_GRID_SIZE,
                                physical_layout: createDefaultPhysicalLayout(DEFAULT_GRID_SIZE),
                                layers: Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i, DEFAULT_GRID_SIZE))
                            }), "default");
                            setModalContent(prev => ({ ...prev, title: "No Device Config", message: "layers.json not found or empty on device. Starting with default configuration.", autoClose: false }));
                        }
                    } catch (commandError) {
                        addLog(`Device communication failed during initial load: ${commandError.message}. Starting with default configuration.`, "error");
                        loadConfigFromJson(JSON.stringify({
                            grid_size: DEFAULT_GRID_SIZE,
                            physical_layout: createDefaultPhysicalLayout(DEFAULT_GRID_SIZE),
                            layers: Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i, DEFAULT_GRID_SIZE))
                        }), "default");
                        setModalContent(prev => ({ ...prev, title: "Device Communication Failed", message: `Failed to communicate with Pico: ${commandError.message}. Starting with default configuration.`, autoClose: false }));
                    }
                    // --- END SIMPLIFIED CONNECTION LOGIC ---

                    // Add a disconnect event listener
                    selectedPort.addEventListener('disconnect', () => {
                        // Release locks on reader and writer if they are held.
                        if (readerRef.current && readerRef.current.locked) readerRef.current.releaseLock(); 
                        if (writerRef.current && writerRef.current.locked) writerRef.current.releaseLock();
                        setIsConnected(false);
                        setPort(null);
                        readerRef.current = null; 
                        writerRef.current = null; 
                        setModalContent({
                            title: "Disconnected",
                            message: "Pico disconnected.",
                            onConfirm: undefined,
                            onCancel: undefined,
                            autoClose: false
                        });
                        setShowModal(true); 
                        addLog("Pico disconnected.", "warn");
                    });

                } catch (error) {
                    setIsConnected(false); 
                    setModalContent({
                        title: "Connection Failed",
                        message: "Failed to connect to Pico: " + error.message,
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false
                    });
                    setShowModal(true); 
                    addLog(`Failed to connect to Pico: ${error.message}`, "error");
                } finally {
                    setIsLoadingDeviceConfig(false); 
                }
            };

            const uploadToDevice = async () => {
                try {
                    // Check if Web Serial API is supported.
                    if (!webSerialSupported) {
                        setModalContent({
                            title: "Web Serial API Not Supported",
                            message: "Your browser does not support the Web Serial API. Please use a Chromium-based browser (e.g., Chrome, Edge) to upload to device.",
                            onConfirm: undefined,
                            onCancel: undefined,
                            autoClose: false
                        });
                        setShowModal(true);
                        addLog("Web Serial API not supported.", "error");
                        return;
                    }

                    // Ensure connection is complete before uploading.
                    if (!isConnected) { 
                        setModalContent({
                            title: "Not Connected",
                            message: "Please connect to your Pico device before uploading.",
                            onConfirm: undefined,
                            onCancel: undefined,
                            autoClose: false
                        });
                        setShowModal(true);
                        addLog("Not connected for upload.", "warn");
                        return;
                    }

                    // Prepare the layers data for upload.
                    const layersForUpload = [];
                    keymap.slice(0, numLayers).forEach((layerData, lIdx) => {
                        const layerName = layerData.name || `Layer ${lIdx}`;
                        
                        const uploadKeys = Array(gridSize * gridSize).fill(""); 
                        const uploadLabels = Array(gridSize * gridSize).fill("");

                        physicalLayout.forEach(layoutItem => {
                            if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < layerData.keys.length) {
                                uploadKeys[layoutItem.index] = layerData.keys[layoutItem.index] || "NO_OP"; 
                                uploadLabels[layoutItem.index] = layerData.labels[layoutItem.index] || "";
                            }
                        });

                        layersForUpload.push({
                            name: layerName,
                            labels: uploadLabels,
                            keys: uploadKeys
                        });
                    });

                    // Assemble the full configuration object for upload.
                    const fullUploadData = {
                        grid_size: gridSize, 
                        physical_layout: physicalLayout, 
                        layers: layersForUpload, 
                    };

                    // Include macros if defined and if there's at least one layer.
                    if (macros.length > 0 && fullUploadData.layers.length > 0) {
                        fullUploadData.layers[0].macros = macros.map(m => ({ name: m.name, sequence: m.sequence }));
                    }

                    const jsonContent = JSON.stringify(fullUploadData);
                    
                    setModalContent({
                        title: "Uploading...",
                        message: "Uploading layers.json to Pico. Please wait.",
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false
                    });
                    setShowModal(true);
                    addLog("Starting layers.json upload to Pico...", "info");

                    // Send the "put" command.
                    await appSendRawCommand("PUT layers.json"); 
                    // Directly send the raw JSON content followed by <EOF>
                    await writerRef.current.write(encoder.encode(jsonContent + "\n<EOF>\n"));
                    addLog("File content and <EOF> sent.", "info");

                    // Wait for "FILE RECEIVED" confirmation
                    const responseLine = await appReadAcknowledgement("FILE RECEIVED"); // Expect specific acknowledgement
                    if (responseLine === "FILE RECEIVED") {
                         setModalContent({
                            title: "Upload Successful",
                            message: "Configuration uploaded successfully!",
                            onConfirm: undefined,
                            onCancel: undefined,
                            autoClose: true 
                        });
                        addLog("Configuration uploaded successfully!", "success");
                    } else {
                        throw new Error(`Device did not confirm FILE RECEIVED, got: "${responseLine}"`);
                    }
                } catch (err) {
                    setModalContent({
                        title: "Upload Failed",
                        message: "Failed to upload: " + err.message,
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false 
                    });
                    addLog(`Upload failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleGetFile = async (filename) => {
                try {
                    // Ensure connection is complete before getting a file.
                    if (!isConnected) { 
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device before checking files.", onConfirm: undefined, onCancel: undefined, autoClose: false });
                        setShowModal(true);
                        addLog("Not connected for file check.", "warn");
                        return;
                    }
                    setModalContent({ title: "Checking...", message: `Checking ${filename} on Pico. Please wait.`, onConfirm: undefined, onCancel: undefined, autoClose: false });
                    setShowModal(true);
                    addLog(`Starting check of ${filename} on Pico...`, "info");
                    
                    // Send the "get" command for the specified file.
                    await appSendRawCommand(`GET ${filename}`); // Use raw command for GET
                    
                    // Use appReadFileContent to get the full file content
                    const fileContent = await appReadFileContent(); 

                    setLastDownloadedFileContent(fileContent); // Store for potential download

                    // If content is received, display it in the settings tab.
                    if (fileContent.length > 0) { 
                        try {
                            const parsed = JSON.parse(fileContent);
                            setJsonInput(JSON.stringify(parsed, null, 2));
                        } catch (parseError) {
                            setJsonInput(fileContent); // If not valid JSON, display as plain text
                            addLog(`Received file "${filename}" is not valid JSON. Displaying as plain text.`, "warn");
                        }
                        
                        setActiveTab('settings'); // Switch to settings tab to show the file content
                        setModalContent({ 
                            title: "Check Successful", 
                            message: `${filename} content loaded into settings tab.`,
                            onConfirm: undefined,
                            onCancel: undefined,
                            autoClose: true 
                        });
                        addLog(`${filename} content loaded into settings tab.`, "success");
                    } else {
                        // This might happen if the file is empty or not found (and device sends <EOF> immediately)
                        setJsonInput(""); // Clear JSON input if file is empty
                        throw new Error(`No content received for "${filename}". File might be empty or not exist.`);
                    }
                } catch (err) {
                    setModalContent({ 
                        title: "Check Failed", 
                        message: `Failed to check ${filename}: ${err.message}`,
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false 
                    });
                    addLog(`Check of ${filename} failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleDeleteFile = async (filename) => {
                try {
                    // Ensure connection is complete before deleting a file.
                    if (!isConnected) { 
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device before deleting files.", onConfirm: undefined, onCancel: undefined, autoClose: false });
                        setShowModal(true);
                        addLog("Not connected for file deletion.", "warn");
                        return;
                    }
                    setModalContent({
                        title: "Confirm Delete",
                        message: `Are you sure you want to delete ${filename} from Pico?`,
                        onConfirm: async () => {
                            setShowModal(false); // Close confirmation modal before proceeding with delete operation
                            setModalContent({ title: "Deleting...", message: `Deleting ${filename} from Pico. Please wait.`, onConfirm: undefined, onCancel: undefined, autoClose: false });
                            setShowModal(true);
                            addLog(`Confirming deletion of ${filename}...`, "info");
                            
                            // Send the "del" command for the specified file.
                            await appSendRawCommand(`DEL ${filename}`);
                            const responseLine = await appReadAcknowledgement("DELETED"); // Expect specific acknowledgement
                            
                            // Check the response status for success.
                            if (responseLine === "DELETED") {
                                setModalContent({ title: "Delete Successful", message: `${filename} deleted.`, onConfirm: undefined, onCancel: undefined, autoClose: true }); 
                                addLog(`${filename} deleted successfully.`, "success");
                            } else {
                                // If the response is an error message from the device, use it.
                                const errorMatch = responseLine.match(/ERROR: (.+)/);
                                if (errorMatch) {
                                    throw new Error(errorMatch[1]);
                                }
                                throw new Error(`Unknown error during deletion. Expected 'DELETED' status, got: "${responseLine}"`);
                            }
                            setShowModal(true);
                        },
                        onCancel: () => {
                            setShowModal(false);
                            addLog(`Deletion of ${filename} cancelled.`, "info");
                        }
                    });
                    setShowModal(true);
                } catch (err) {
                    setModalContent({ title: "Delete Failed", message: `Failed to delete ${filename}: ${err.message}`, onConfirm: undefined, onCancel: undefined, autoClose: false });
                    addLog(`Deletion of ${filename} failed: ${err.message}`, "error");
                    setShowModal(true);
                }
            };

            const handleListFiles = async () => {
                try {
                    if (!isConnected) {
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device before listing files.", onConfirm: undefined, onCancel: undefined, autoClose: false });
                        setShowModal(true);
                        addLog("Not connected for listing files.", "warn");
                        return;
                    }
                    setModalContent({ title: "Listing Files...", message: "Requesting file list from Pico. Please wait.", onConfirm: undefined, onCancel: undefined, autoClose: false });
                    setShowModal(true);
                    addLog("Requesting file list from Pico...", "info");

                    await appSendRawCommand("LIST");

                    let fileList = [];
                    let line;
                    // Read lines until <END>
                    // Use appReadAcknowledgement to get each line, but don't pass expectedResponse for the lines themselves
                    while ((line = await appReadAcknowledgement(null, 3000)) !== "<END>") { // Reduced timeout for individual lines in a list
                        if (line.startsWith("Files:")) {
                            continue;
                        }
                        if (!line.startsWith(".")) {
                            fileList.push(line);
                        }
                    }
                    
                    setModalContent({ title: "Files Listed", message: `Found ${fileList.length} user files on device. Details in log.`, onConfirm: undefined, onCancel: undefined, autoClose: true });
                    addLog("--- User Files on Device ---", "info");
                    fileList.forEach(file => addLog(`- ${file}`, "filelist"));
                    addLog("--- End of User File List ---", "info");
                } catch (err) {
                    setModalContent({ title: "List Files Failed", message: `Failed to list files: ${err.message}`, onConfirm: undefined, onCancel: undefined, autoClose: false });
                    addLog(`List files failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleDownloadLastGet = () => {
                if (lastDownloadedFileContent) {
                    const blob = new Blob([lastDownloadedFileContent], { type: "text/plain" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "downloaded_file.txt"; // Generic name, could be made dynamic
                    a.click();
                    URL.revokeObjectURL(url); // Clean up
                    setModalContent({
                        title: "Download Initiated",
                        message: "Last fetched file content downloaded to your computer.",
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: true
                    });
                    addLog("Last fetched file content downloaded.", "success");
                } else {
                    setModalContent({
                        title: "No Content to Download",
                        message: "No file content has been fetched via 'Check layers.json on Device' yet.",
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false
                    });
                    addLog("No content available for download.", "warn");
                }
                setShowModal(true);
            };


            // State for the current grid size (e.g., 3 for 3x3, 4 for 4x4)
            const [gridSize, setGridSize] = useState(DEFAULT_GRID_SIZE);

            // State for the physical layout of the keys
            const [physicalLayout, setPhysicalLayout] = useState(() => createDefaultPhysicalLayout(DEFAULT_GRID_SIZE));
            
            // State for number of layers
            const [numLayers, setNumLayers] = useState(DEFAULT_LAYERS);

            // State for the keymap, initialized based on numLayers and gridSize
            const [keymap, setKeymap] = useState(() => Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i, DEFAULT_GRID_SIZE)));
            
            // Effect to update keymap when numLayers or gridSize changes
            useEffect(() => {
                const numKeysInCurrentGrid = gridSize * gridSize;
                setKeymap(prevKeymap => {
                    const newKeymap = Array(numLayers).fill().map((_, i) => {
                        if (prevKeymap[i]) {
                            const currentKeys = prevKeymap[i].keys || [];
                            const currentLabels = prevKeymap[i].labels || [];

                            const keys = Array(numKeysInCurrentGrid).fill(null);
                            const labels = Array(numKeysInCurrentGrid).fill('');

                            physicalLayout.forEach(layoutItem => {
                                if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < currentKeys.length) {
                                    keys[layoutItem.index] = currentKeys[layoutItem.index];
                                    labels[layoutItem.index] = currentLabels[layoutItem.index];
                                }
                            });

                            return { ...prevKeymap[i], keys: keys, labels: labels }; 
                        } else {
                            return createEmptyLayer(i, gridSize); 
                        }
                    });
                    return newKeymap;
                });

                setCurrentLayer(prevCurrentLayer => {
                    if (prevCurrentLayer >= numLayers) {
                        return numLayers > 0 ? numLayers - 1 : 0; 
                    }
                    return prevCurrentLayer;
                });
                addLog(`Number of layers changed to ${numLayers} or grid size changed to ${gridSize}.`, "info");
            }, [numLayers, gridSize, physicalLayout]); 

            const [shortcutPool, setShortcutPool] = useState(Object.fromEntries(Object.entries(presets).map(([k, v]) => [k, [...v]])));
            const [showModal, setShowModal] = useState(false);
            const [modalContent, setModalContent] = useState({ title: "", message: "" });
            const [draggedShortcut, setDraggedShortcut] = useState(null);
            const [activeTab, setActiveTab] = useState('keymap');
            const [jsonInput, setJsonInput] = useState('');
            const [currentLayer, setCurrentLayer] = useState(0); 
            const [selectedKeymapCell, setSelectedKeymapCell] = useState(null); 
            const [webSerialSupported, setWebSerialSupported] = useState(false);

            const [showLayerAssignmentModal, setShowLayerAssignmentModal] = useState(false);
            const [layerAssignmentModalData, setLayerAssignmentModalData] = useState({ type: '', targetCell: null });


            const [macros, setMacros] = useState([
                { id: 1, name: "Macro 1", sequence: "Hello World!" }, 
                { id: 2, name: "Macro 2", sequence: "control+alt+t" }, 
            ]);
            const [nextMacroId, setNextMacroId] = useState(3);

            useEffect(() => {
                loadProfile();
                setWebSerialSupported('serial' in navigator);
            }, []);

            const assignLayerShortcut = (type, layerNum) => {
                const { index, layer } = layerAssignmentModalData.targetCell;

                const newKeymap = JSON.parse(JSON.stringify(keymap));

                const newCombo = `${type}(${layerNum})`;
                let newDescription = "";
                switch (type) {
                    case "TO": newDescription = `Permanent to Layer ${layerNum}`; break;
                    case "MO": newDescription = `Momentary to Layer ${layerNum}`; break;
                    case "TT": newDescription = `Toggle Layer ${layerNum}`; break;
                    case "DF": newDescription = `Set Default Layer ${layerNum}`; break;
                }

                if (index < newKeymap[layer].keys.length) { 
                    newKeymap[layer].keys[index] = newCombo;
                    newKeymap[layer].labels[index] = newDescription;
                    setKeymap(newKeymap);
                    addLog(`Assigned ${newCombo} to Layer ${layer}, Index ${index}.`, "info");
                } else {
                    addLog(`Attempted to assign layer shortcut to out-of-bounds index ${index} on Layer ${layer}.`, "error");
                    setModalContent({
                        title: "Assignment Error",
                        message: `The selected key position (index ${index}) is outside the current keymap grid. This might indicate an issue with your physical layout.`
                    });
                    setShowModal(true);
                }
                setShowLayerAssignmentModal(false); 
                setSelectedKeymapCell(null); 
            };

            const handleDrop = async (e, flatIndex) => { 
                e.preventDefault();
                const data = e.dataTransfer.getData("text/plain");
                let droppedItem;

                try {
                    droppedItem = JSON.parse(data);
                } catch (error) {
                    console.error("Failed to parse dropped data:", error);
                    addLog("Failed to parse dropped data: " + error.message, "error");
                    setDraggedShortcut(null);
                    return;
                }

                const specialLayerKeycodeTypes = ["TO", "MO", "TT", "DF"];

                if (droppedItem.isKeymapCell) {
                    const sourceFlatIndex = droppedItem.sourceFlatIndex;
                    const sourceLayer = droppedItem.sourceLayer; // Corrected to sourceLayer
                    const newKeymap = JSON.parse(JSON.stringify(keymap));

                    if (sourceLayer === currentLayer) {
                        const tempKey = newKeymap[currentLayer].keys[flatIndex];
                        const tempLabel = newKeymap[currentLayer].labels[flatIndex];

                        newKeymap[currentLayer].keys[flatIndex] = newKeymap[currentLayer].keys[sourceFlatIndex];
                        newKeymap[currentLayer].labels[flatIndex] = newKeymap[currentLayer].labels[sourceFlatIndex];

                        newKeymap[currentLayer].keys[sourceFlatIndex] = tempKey;
                        newKeymap[currentLayer].labels[sourceFlatIndex] = tempLabel;
                    } else {
                        newKeymap[currentLayer].keys[flatIndex] = droppedItem.cell.combo; // Corrected to droppedItem.cell.combo
                        newKeymap[currentLayer].labels[flatIndex] = droppedItem.cell.description; // Corrected to droppedItem.cell.description
                    }
                    setKeymap(newKeymap);
                    addLog(`Key assigned to Layer ${currentLayer}, Index ${flatIndex}.`, "info");

                } else if (specialLayerKeycodeTypes.includes(droppedItem.combo)) {
                    setLayerAssignmentModalData({ type: droppedItem.combo, targetCell: selectedKeymapCell ? selectedKeymapCell : {index: flatIndex, layer: currentLayer} }); // Use existing selection or current drop target
                    setShowLayerAssignmentModal(true);
                    addLog(`Opened layer assignment modal for ${droppedItem.combo} at Layer ${currentLayer}, Index ${flatIndex}.`, "info");
                } else {
                    const newKeymap = JSON.parse(JSON.stringify(keymap));
                    newKeymap[currentLayer].keys[flatIndex] = droppedItem.combo;
                    newKeymap[currentLayer].labels[flatIndex] = droppedItem.description;
                    setKeymap(newKeymap);
                    addLog(`Key assigned to Layer ${currentLayer}, Index ${flatIndex}.`, "info");
                }

                setDraggedShortcut(null);
                setSelectedKeymapCell(null); 
            };


            const handleKeymapDragStart = (e, cellContent, flatIndex) => { 
                const dragData = JSON.stringify({ isKeymapCell: true, cell: cellContent, sourceFlatIndex: flatIndex, sourceLayer: currentLayer });
                e.dataTransfer.setData("text/plain", dragData);
                setSelectedKeymapCell(null); 
            };

            const handleShortcutDragStart = (e, shortcut) => {
                e.dataTransfer.setData("text/plain", JSON.stringify(shortcut));
                setDraggedShortcut(shortcut);
                setSelectedKeymapCell(null); 
            };

            const handleDragEnd = () => {
                setDraggedShortcut(null);
            };

            const clearKeymapCell = (flatIndex) => { 
                const numKeysInCurrentGrid = gridSize * gridSize;
                const updatedKeymap = keymap.map((layer, lIdx) => {
                    if (lIdx === currentLayer) {
                        const newKeys = [...layer.keys];
                        const newLabels = [...layer.labels];
                        if (flatIndex < newKeys.length) { 
                            newKeys[flatIndex] = null; 
                            newLabels[flatIndex] = ''; 
                        }
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }
                    return layer;
                });
                setKeymap(updatedKeymap);
                setSelectedKeymapCell(null); 
                addLog(`Keymap cell Layer ${currentLayer}, Index ${flatIndex} cleared.`, "info");
            };

            const handleKeymapCellClick = (flatIndex, layer) => { 
                if (selectedKeymapCell && selectedKeymapCell.index === flatIndex && selectedKeymapCell.layer === layer) {
                    setSelectedKeymapCell(null);
                    addLog(`Deselected keymap cell Layer ${layer}, Index ${flatIndex}.`, "info");
                } else {
                    setSelectedKeymapCell({ index: flatIndex, layer }); 
                    addLog(`Selected keymap cell Layer ${layer}, Index ${flatIndex}.`, "info");
                }
            };

            const handleShortcutClick = async (shortcut) => { 
                if (selectedKeymapCell) {
                    const specialLayerKeycodeTypes = ["TO", "MO", "TT", "DF"];
                    if (specialLayerKeycodeTypes.includes(shortcut.combo)) {
                        setLayerAssignmentModalData({ type: shortcut.combo, targetCell: selectedKeymapCell });
                        setShowLayerAssignmentModal(true);
                        addLog(`Opened layer assignment modal for ${shortcut.combo} at selected cell.`, "info");
                    } else {
                        const { index, layer } = selectedKeymapCell; 
                        const newKeymap = JSON.parse(JSON.stringify(keymap));
                        if (index < newKeymap[layer].keys.length) { 
                            newKeymap[layer].keys[index] = shortcut.combo;
                            newKeymap[layer].labels[index] = shortcut.description; 
                        } else {
                            addLog(`Attempted to assign shortcut to out-of-bounds index ${index} on Layer ${layer}.`, "error");
                            setModalContent({
                                title: "Assignment Error",
                                message: `The selected key position (index ${index}) is outside the current keymap grid. This might indicate an issue with your physical layout.`
                            });
                            setShowModal(true);
                            setSelectedKeymapCell(null); 
                            return;
                        }
                        setKeymap(newKeymap);
                        setSelectedKeymapCell(null); 
                        addLog(`Assigned "${shortcut.combo}" to Layer ${layer}, Index ${index}.`, "info");
                    }
                } else {
                    setModalContent({
                        title: "No Keymap Cell Selected",
                        message: "Please click a keymap cell first to select it, then click a shortcut to assign it."
                    });
                    setShowModal(true);
                    addLog("Attempted to assign shortcut without selecting a keymap cell.", "warn");
                }
            };

            const clearCurrentLayer = () => {
                const numKeysInCurrentGrid = gridSize * gridSize;
                setModalContent({
                    title: "Confirm Clear Layer",
                    message: `Are you sure you want to clear all keys on Layer ${currentLayer}? This action cannot be undone.`,
                    onConfirm: () => {
                        const updatedKeymap = keymap.map((layer, lIdx) =>
                            lIdx === currentLayer
                                ? { ...layer, keys: Array(numKeysInCurrentGrid).fill(null), labels: Array(numKeysInCurrentGrid).fill('') }
                                : layer
                        );
                        setKeymap(updatedKeymap);
                        setSelectedKeymapCell(null); 
                        setShowModal(false);
                        addLog(`All keys on Layer ${currentLayer} cleared.`, "info");
                    },
                    onCancel: () => {
                        setShowModal(false);
                        addLog(`Deletion of Layer ${currentLayer} cancelled.`, "info");
                    }
                });
                setShowModal(true);
            };


            // Profile Management
            const saveProfile = () => {
                const profileData = {
                    keymap: keymap, 
                    physicalLayout: physicalLayout, 
                    macros: macros,
                    numLayers: numLayers, 
                    grid_size: gridSize 
                };
                localStorage.setItem("trkey_profile", JSON.stringify(profileData));
                setModalContent({
                    title: "Profile Saved",
                    message: "Profile saved to browser storage.",
                    onConfirm: undefined,
                    onCancel: undefined,
                    autoClose: true
                });
                setShowModal(true);
                addLog("Profile saved to browser storage.", "info");
            };

            const loadProfile = () => {
                const saved = localStorage.getItem("trkey_profile");
                if (saved) {
                    const profileData = JSON.parse(saved);
                    loadConfigFromJson(JSON.stringify(profileData), "fromBrowser");
                    setModalContent({
                        title: "Profile Loaded",
                        message: "Profile loaded successfully.",
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: true
                    });
                    addLog("Profile loaded from browser storage.", "info");
                } else {
                    setModalContent({
                        title: "No Profile Found",
                        message: "No saved profile found. Initializing with default layers and layout.",
                        onConfirm: undefined,
                        onCancel: undefined,
                        autoClose: false
                    });
                    setGridSize(DEFAULT_GRID_SIZE);
                    setNumLayers(DEFAULT_LAYERS);
                    setPhysicalLayout(createDefaultPhysicalLayout(DEFAULT_GRID_SIZE));
                    setKeymap(Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i, DEFAULT_GRID_SIZE)));
                    setMacros([]); 
                    addLog("No saved profile found in browser storage. Initialized with default layers and layout.", "info");
                }
                setShowModal(true);
            };

            // Export and Upload
            const exportKeymap = () => {
                const layersForExport = []; 

                keymap.slice(0, numLayers).forEach((layerData, lIdx) => {
                    const layerName = layerData.name || `Layer ${lIdx}`;
                    
                    const exportKeys = Array(gridSize * gridSize).fill(""); 
                    const exportLabels = Array(gridSize * gridSize).fill("");

                    physicalLayout.forEach(layoutItem => {
                        if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < layerData.keys.length) {
                             exportKeys[layoutItem.index] = layerData.keys[layoutItem.index] || "NO_OP"; 
                             exportLabels[layoutItem.index] = layerData.labels[layoutItem.index] || "";
                        }
                    }
                    );

                    layersForExport.push({
                        name: layerName,
                        labels: exportLabels,
                        keys: exportKeys
                    });
                });

                const fullExportData = {
                    grid_size: gridSize, 
                    physical_layout: physicalLayout, 
                    layers: layersForExport 
                };

                if (macros.length > 0) {
                    if (fullExportData.layers.length > 0) {
                         fullExportData.layers[0].macros = macros.map(m => ({ name: m.name, sequence: m.sequence }));
                    }
                }

                const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "layers.json"; 
                a.click();
                setModalContent({
                    title: "Export Successful",
                    message: "Configuration exported as layers.json. Drag this file onto your CIRCUITPY drive.",
                    onConfirm: undefined,
                    onCancel: undefined,
                    autoClose: true
                });
                setShowModal(true);
                addLog("Configuration exported as layers.json.", "info");
            };


            // Refactored JSON Load function (from manual input or auto-load)
            const loadConfigFromJson = (jsonString, source = "manual") => {
                try {
                    // Extract potential JSON object (starts with '{', ends with '}')
                    const jsonStartIndex = jsonString.indexOf('{');
                    const jsonEndIndex = jsonString.lastIndexOf('}');

                    let cleanedJsonString = jsonString;

                    if (jsonStartIndex !== -1 && jsonEndIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                        cleanedJsonString = jsonString.substring(jsonStartIndex, jsonEndIndex + 1);
                        addLog(`Extracted potential JSON substring from received data (length: ${cleanedJsonString.length}).`, "debug");
                    } else {
                        addLog("Could not find a clear JSON object boundary ({}). Attempting to parse raw string.", "warn");
                    }

                    const parsedJson = JSON.parse(cleanedJsonString);
                    addLog(`Loading configuration from ${source} source.`, "info");

                    if (typeof parsedJson === 'object' && parsedJson !== null && Array.isArray(parsedJson.layers)) {
                        const loadedGridSize = parsedJson.grid_size || DEFAULT_GRID_SIZE;
                        const clampedGridSize = Math.max(MIN_GRID_SIZE, Math.min(MAX_GRID_SIZE, loadedGridSize));
                        setGridSize(clampedGridSize);
                        const numKeysInLoadedGrid = clampedGridSize * clampedGridSize;

                        let loadedPhysicalLayout;
                        if (Array.isArray(parsedJson.physical_layout)) {
                            const validatedLayout = parsedJson.physical_layout.map(item => {
                                if (item === null || (typeof item === 'object' && item !== null && 'index' in item && 'row' in item && 'col' in item)) {
                                    return item;
                                }
                                return null;
                            }).filter(item => item !== null && item.row < clampedGridSize && item.col < clampedGridSize);
                            validatedLayout.sort((a,b) => a.index - b.index);
                            loadedPhysicalLayout = validatedLayout;
                            addLog(`Physical layout loaded from JSON. Detected ${loadedPhysicalLayout.length} active key positions.`, "info");
                        } else {
                            loadedPhysicalLayout = createDefaultPhysicalLayout(clampedGridSize); 
                            addLog("No valid 'physical_layout' found in JSON, defaulting to new grid size layout.", "warn");
                        }
                        setPhysicalLayout(loadedPhysicalLayout); 

                        const loadedLayers = parsedJson.layers;
                        const loadedNumLayers = Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, loadedLayers.length));
                        setNumLayers(loadedNumLayers); 

                        const newKeymap = Array(loadedNumLayers).fill().map((_, layerIdx) => {
                            if (loadedLayers[layerIdx]) {
                                const layerKeys = Array.isArray(loadedLayers[layerIdx].keys) ? loadedLayers[layerIdx].keys : [];
                                const layerLabels = Array.isArray(loadedLayers[layerIdx].labels) ? loadedLayers[layerIdx].labels : [];

                                const keys = Array(numKeysInLoadedGrid).fill(null);
                                const labels = Array(numKeysInLoadedGrid).fill('');

                                // Iterate through the loadedPhysicalLayout to correctly map keys and labels
                                loadedPhysicalLayout.forEach(layoutItem => {
                                    if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < numKeysInLoadedGrid) {
                                        keys[layoutItem.index] = layerKeys[layoutItem.index] || null;
                                        labels[layoutItem.index] = layerLabels[layoutItem.index] || '';
                                    }
                                }
                                );

                                return {
                                    name: loadedLayers[layerIdx].name || `Layer ${layerIdx}`,
                                    labels: labels,
                                    keys: keys,
                                    macros: loadedLayers[layerIdx].macros || []
                                };
                            } else {
                                return createEmptyLayer(layerIdx, clampedGridSize);
                            }
                        });
                        setKeymap(newKeymap);

                        let loadedMacros = [];
                        let maxMacroId = 0;
                        parsedJson.layers.forEach(layerData => {
                            if (layerData.macros && Array.isArray(layerData.macros)) {
                                const newMacrosForLayer = layerData.macros.map((m) => {
                                    const id = m.id || nextMacroId + loadedMacros.length; 
                                    maxMacroId = Math.max(maxMacroId, id);
                                    return { id: id, name: m.name, sequence: m.sequence };
                                });
                                loadedMacros = [...loadedMacros, ...newMacrosForLayer];
                            }
                        });
                        setMacros(loadedMacros);
                        setNextMacroId(maxMacroId + 1);

                        setCurrentLayer(prevCurrentLayer => {
                            if (prevCurrentLayer >= loadedNumLayers) {
                                return loadedNumLayers > 0 ? loadedNumLayers - 1 : 0;
                            }
                            return prevCurrentLayer;
                        });

                        setJsonInput(JSON.stringify(parsedJson, null, 2)); 

                        addLog(`Configuration loaded from ${source} successfully.`, "success");
                    } else {
                        throw new Error("The pasted JSON does not contain a valid configuration. Expected a root object with 'physical_layout' (optional) and a 'layers' array.");
                    }
                } catch (error) {
                    addLog(`Failed to load configuration from ${source}: ${error.message}`, "error");
                    if (source === "manual" || source === "fromDevice") { // Show modal for device load errors as well
                        setModalContent({
                            title: `Configuration Load Error (${source})`,
                            message: `Failed to load configuration: ${error.message}. Please check the JSON format.`,
                            onConfirm: undefined,
                            onCancel: undefined,
                            autoClose: false
                        });
                        setShowModal(true);
                    }
                }
            };


            // Macro functions
            const addMacro = () => {
                const name = prompt("Enter macro name (e.g., Macro 1):");
                if (!name) {
                    addLog("Macro creation cancelled (no name provided).", "info");
                    return;
                }
                const sequence = prompt("Enter macro sequence (e.g., 'Hello World!'):");
                if (sequence) {
                    setMacros(prev => [...prev, { id: nextMacroId, name, sequence }]);
                    setNextMacroId(prev => prev + 1);
                    addLog(`Macro "${name}" added.`, "info");
                } else {
                    addLog("Macro creation cancelled (no sequence provided).", "info");
                }
            };

            const editMacro = (id) => {
                const macroToEdit = macros.find(m => m.id === id);
                if (!macroToEdit) {
                    addLog(`Attempted to edit non-existent macro with ID: ${id}.`, "warn");
                    return;
                }

                const newName = prompt(`Edit name for "${macroToEdit.name}":`, macroToEdit.name);
                if (newName === null) {
                    addLog(`Edit for macro "${macroToEdit.name}" cancelled (name).`, "info");
                    return;
                }

                const newSequence = prompt(`Edit sequence for "${macroToEdit.name}":`, macroToEdit.sequence);
                if (newSequence === null) {
                    addLog(`Edit for macro "${macroToEdit.name}" cancelled (sequence).`, "info");
                    return;
                }

                setMacros(prev => prev.map(m =>
                    m.id === id ? { ...m, name: newName, sequence: newSequence } : m
                ));
                addLog(`Macro "${macroToEdit.name}" (ID: ${id}) updated.`, "info");
            };

            const deleteMacro = (id) => {
                setModalContent({
                    title: "Confirm Delete",
                    message: "Are you sure you want to delete this macro?",
                    onConfirm: () => {
                        setMacros(prev => prev.filter(m => m.id !== id));
                        setShowModal(false);
                        addLog(`Macro with ID: ${id} deleted.`, "info");
                    },
                    onCancel: () => {
                        setShowModal(false);
                        addLog(`Deletion of macro with ID: ${id} cancelled.`, "info");
                    }
                });
                setShowModal(true);
            };

            return (
                <div className="min-h-screen bg-zinc-800 text-white flex font-inter">
                    {/* Sidebar */}
                    <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />

                    {/* Main Content Area */}
                    <div className="flex-1 flex flex-col p-4 overflow-y-auto"> 
                         {/* Web Serial Status Indicator */}
                        <div className="flex justify-end mb-4 space-x-2">
                            <span className={`text-sm px-3 py-1 rounded-full ${webSerialSupported ? 'bg-green-600' : 'bg-red-600'} text-white`}>
                                Web Serial: {webSerialSupported ? 'Supported' : 'Not Supported'}
                            </span>
                            <span className={`text-sm px-3 py-1 rounded-full ${isConnected ? 'bg-green-600' : 'bg-red-600'} text-white`}>
                                Connected: {isConnected ? 'Yes' : 'No'}
                            </span>
                        </div>
                        {isLoadingDeviceConfig && (
                            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
                                <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl border-2 border-red-500 flex items-center space-x-4 relative"> 
                                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-red-500"></div>
                                    <p className="text-lg">Loading configuration from device...</p>
                                    <button
                                        onClick={() => setIsLoadingDeviceConfig(false)}
                                        className="absolute top-2 right-2 text-zinc-400 hover:text-red-500 transition-colors duration-200"
                                        title="Close loading message"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        )}

                        {activeTab === 'keymap' && (
                            <div className="flex-1 p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-y-auto"> 
                                <h1 className="text-4xl font-extrabold text-red-400 mb-4">KEYMAP CONFIGURATION</h1>
                                <h2 className="2xl font-bold text-zinc-300 mb-8">Currently Viewing: Layer {currentLayer}</h2>
                                <KeymapGrid
                                    keymap={keymap}
                                    handleDrop={handleDrop}
                                    handleKeymapDragStart={handleKeymapDragStart}
                                    handleDragEnd={handleDragEnd}
                                    clearKeymapCell={clearKeymapCell}
                                    currentLayer={currentLayer} 
                                    setCurrentLayer={setCurrentLayer} 
                                    selectedKeymapCell={selectedKeymapCell} 
                                    handleKeymapCellClick={handleKeymapCellClick} 
                                    clearCurrentLayer={clearCurrentLayer} 
                                    numLayers={numLayers} 
                                    physicalLayout={physicalLayout} 
                                    gridSize={gridSize} 
                                />
                                <h2 className="3xl font-bold text-red-400 mb-6">SHORTCUTS</h2>
                                <ShortcutPool
                                    shortcutPool={shortcutPool}
                                    draggedShortcut={draggedShortcut}
                                    handleShortcutDragStart={handleShortcutDragStart}
                                    handleDragEnd={handleDragEnd}
                                    selectedKeymapCell={selectedKeymapCell} 
                                    handleShortcutClick={handleShortcutClick} 
                                />
                            </div>
                        )}

                        {activeTab === 'layout' && (
                            <div className="flex-1 p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-y-auto"> 
                                <LayoutPage 
                                    gridSize={gridSize}
                                    setGridSize={setGridSize} 
                                    physicalLayout={physicalLayout}
                                    setPhysicalLayout={setPhysicalLayout}
                                    keymap={keymap} 
                                    setKeymap={setKeymap} 
                                    exportKeymap={exportKeymap} 
                                    uploadToDevice={uploadToDevice} 
                                    isConnected={isConnected} 
                                    handleConnectPico={handleConnectPico} 
                                    webSerialSupported={webSerialSupported} 
                                />
                            </div>
                        )}

                        {activeTab === 'macros' && (
                            <div className="flex-1 p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-y-auto"> 
                                <MacroManagement
                                    macros={macros}
                                    addMacro={addMacro}
                                    editMacro={editMacro}
                                    deleteMacro={deleteMacro}
                                />
                            </div>
                        )}

                        {activeTab === 'connect-load' && (
                            <div className="flex-1 p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-y-auto"> 
                                <ConnectLoad 
                                    saveProfile={saveProfile}
                                    loadProfile={loadProfile}
                                    exportKeymap={exportKeymap}
                                    uploadToDevice={uploadToDevice}
                                    isConnected={isConnected} 
                                    handleConnectPico={handleConnectPico} 
                                    handleGetFile={handleGetFile} 
                                    handleDeleteFile={handleDeleteFile} 
                                    logs={logs} 
                                    clearLogs={clearLogs} 
                                    showLogDropdown={showLogDropdown} 
                                    toggleLogDropdown={toggleLogDropdown} 
                                    webSerialSupported={webSerialSupported} 
                                    isLoadingDeviceConfig={isLoadingDeviceConfig} 
                                    handleListFiles={handleListFiles}
                                    handleDownloadLastGet={handleDownloadLastGet}
                                    lastDownloadedFileContent={lastDownloadedFileContent}
                                />
                            </div>
                        )}

                        {activeTab === 'settings' && (
                            <div className="flex-1 p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-y-auto"> 
                                <Settings
                                    jsonInput={jsonInput}
                                    setJsonInput={setJsonInput}
                                    loadConfigFromJson={loadConfigFromJson} 
                                    numLayers={numLayers} 
                                    setNumLayers={setNumLayers} 
                                    physicalLayout={physicalLayout} 
                                />
                            </div>
                        )}

                        {activeTab === 'keytester' && (
                            <div className="flex-1 p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-y-auto"> 
                                <KeyTester activeTab={activeTab} />
                            </div>
                        )}
                    </div>

                    {/* Modals */}
                    <Modal
                        show={showModal && !modalContent.onConfirm}
                        title={modalContent.title}
                        message={modalContent.message}
                        onClose={() => setShowModal(false)}
                        autoClose={modalContent.autoClose} 
                    />
                    <ConfirmationModal
                        show={showModal && modalContent.onConfirm}
                        title={modalContent.title}
                        message={modalContent.message}
                        onConfirm={modalContent.onConfirm}
                        onCancel={modalContent.onCancel}
                    />
                    {/* NEW: Layer Assignment Modal */}
                    <LayerAssignmentModal
                        show={showLayerAssignmentModal}
                        type={layerAssignmentModalData.type}
                        maxLayer={numLayers - 1} 
                        onAssign={assignLayerShortcut}
                        onCancel={() => {
                            setShowLayerAssignmentModal(false);
                            setSelectedKeymapCell(null); 
                            addLog("Layer assignment cancelled.", "info");
                        }}
                        setShowAppModal={setShowModal}
                        setAppModalContent={setModalContent}
                    />
                </div>
            );
        }

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
