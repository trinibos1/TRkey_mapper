<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trkey Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom scrollbar styling for Tailwind's custom-scrollbar class */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #3f3f46; /* zinc-700 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #ef4444; /* red-500 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #dc2626; /* red-600 */
        }
        /* Allow body and root to scroll */
        html, body, #root {
            min-height: 100%; /* Ensure they take at least full height, but can grow */
            margin: 0;
        }
    </style>
</head>
<body class="font-inter">
    <div id="root"></div>

    <script type="text/babel">
        // All React component code consolidated here

        // Explicitly get React and ReactDOM from the window object
        const React = window.React;
        const ReactDOM = window.ReactDOM;

        // NEW: Define minimum and maximum grid sizes
        const MIN_GRID_SIZE = 2;
        const MAX_GRID_SIZE = 5;
        const DEFAULT_GRID_SIZE = 3; // Default 3x3 grid

        // Constants with ALL shortcuts from the PDF, adapted for CircuitPython Keycode names
        const presets = {
            "STANDARD_KEYS": [
                { combo: "A", description: "A" },
                { combo: "B", description: "B" },
                { combo: "C", description: "C" },
                { combo: "D", description: "D" },
                { combo: "E", description: "E" },
                { combo: "F", description: "F" },
                { combo: "G", description: "G" },
                { combo: "H", description: "H" },
                { combo: "I", description: "I" },
                { combo: "J", description: "J" },
                { combo: "K", description: "K" },
                { combo: "L", description: "L" },
                { combo: "M", description: "M" },
                { combo: "N", description: "N" },
                { combo: "O", description: "O" },
                { combo: "P", description: "P" },
                { combo: "Q", description: "Q" },
                { combo: "R", description: "R" },
                { combo: "S", description: "S" },
                { combo: "T", description: "T" },
                { combo: "U", description: "U" },
                { combo: "V", description: "V" },
                { combo: "W", description: "W" },
                { combo: "X", description: "X" },
                { combo: "Y", description: "Y" },
                { combo: "Z", description: "Z" },
                { combo: "ONE", description: "1" },
                { combo: "TWO", description: "2" },
                { combo: "THREE", description: "3" },
                { combo: "FOUR", description: "4" },
                { combo: "FIVE", description: "5" },
                { combo: "SIX", description: "6" },
                { combo: "SEVEN", description: "7" },
                { combo: "EIGHT", description: "8" },
                { combo: "NINE", description: "9" },
                { combo: "ZERO", description: "0" },
                { combo: "ENTER", description: "Enter" },
                { combo: "ESCAPE", description: "Esc" },
                { combo: "TAB", description: "Tab" },
                { combo: "SPACEBAR", description: "Space" },
                { combo: "BACKSPACE", description: "Bksp" },
                { combo: "DELETE", description: "Del" },
                { combo: "CAPS_LOCK", description: "Caps" },
                { combo: "F1", description: "F1" },
                { combo: "F2", description: "F2" },
                { combo: "F3", description: "F3" },
                { combo: "F4", description: "F4" },
                { combo: "F5", description: "F5" },
                { combo: "F6", description: "F6" },
                { combo: "F7", description: "F7" },
                { combo: "F8", description: "F8" },
                { combo: "F9", description: "F9" },
                { combo: "F10", description: "F10" },
                { combo: "F11", description: "F11" },
                { combo: "F12", description: "F12" },
                { combo: "PRINT_SCREEN", description: "PrtSc" },
                { combo: "SCROLL_LOCK", description: "ScrLk" },
                { combo: "PAUSE", description: "Pause" },
                { combo: "INSERT", description: "Ins" },
                { combo: "HOME", description: "Home" },
                { combo: "PAGE_UP", description: "PgUp" },
                { combo: "PAGE_DOWN", description: "PgDn" },
                { combo: "END", description: "End" },
                { combo: "RIGHT_ARROW", description: "R Arrow" },
                { combo: "LEFT_ARROW", description: "L Arrow" },
                { combo: "DOWN_ARROW", description: "Dn Arrow" },
                { combo: "UP_ARROW", description: "Up Arrow" },
                { combo: "KEYPAD_NUMLOCK", description: "NumLk" },
                { combo: "KEYPAD_SLASH", description: "Kp /" },
                { combo: "KEYPAD_ASTERISK", description: "Kp *" },
                { combo: "KEYPAD_MINUS", description: "Kp -" },
                { combo: "KEYPAD_PLUS", description: "Kp +" },
                { combo: "KEYPAD_ENTER", description: "Kp Ent" },
                { combo: "KEYPAD_ONE", description: "Kp 1" },
                { combo: "KEYPAD_TWO", description: "Kp 2" },
                { combo: "KEYPAD_THREE", description: "Kp 3" },
                { combo: "KEYPAD_FOUR", description: "Kp 4" },
                { combo: "KEYPAD_FIVE", description: "Kp 5" },
                { combo: "KEYPAD_SIX", description: "Kp 6" },
                { combo: "KEYPAD_SEVEN", description: "Kp 7" },
                { combo: "KEYPAD_EIGHT", description: "Kp 8" },
                { combo: "KEYPAD_NINE", description: "Kp 9" },
                { combo: "KEYPAD_ZERO", description: "Kp 0" },
                { combo: "KEYPAD_PERIOD", description: "Kp ." },
                { combo: "NON_US_SLASH", description: "Non-US /" },
                { combo: "APPLICATION", description: "App Key" },
                { combo: "COMMA", description: "Comma" },
                { combo: "PERIOD", description: "Period" },
                { combo: "GRAVE_ACCENT", description: "Grave" },
                { combo: "MINUS", description: "Minus" },
                { combo: "EQUAL", description: "Equal" },
                { combo: "LEFT_BRACKET", description: "L Brkt" },
                { combo: "RIGHT_BRACKET", description: "R Brkt" },
                { combo: "BACKSLASH", description: "Bcksl" },
                { combo: "SEMICOLON", description: "Semicln" },
                { combo: "QUOTE", description: "Quote" },
                { combo: "SLASH", description: "Slash" },
            ],
            "MODIFIER_KEYS": [
                { combo: "LEFT_CONTROL", description: "L Ctrl" },
                { combo: "LEFT_SHIFT", description: "L Shift" },
                { combo: "LEFT_ALT", description: "L Alt" },
                { combo: "LEFT_GUI", description: "L GUI" },
                { combo: "RIGHT_CONTROL", description: "R Ctrl" },
                { combo: "RIGHT_SHIFT", description: "R Shift" },
                { combo: "RIGHT_ALT", description: "R Alt" },
                { combo: "RIGHT_GUI", description: "R GUI" },
            ],
            "COMBINATION_SHORTCUTS": [
                { combo: "CONTROL_C", description: "Copy" },
                { combo: "CONTROL_V", description: "Paste" },
                { combo: "CONTROL_X", description: "Cut" },
                { combo: "CONTROL_Z", description: "Undo" },
                { combo: "CONTROL_Y", description: "Redo" },
                { combo: "CONTROL_S", description: "Save" },
                { combo: "ALT_TAB", description: "App Switch" },
                { combo: "GUI_D", description: "Desktop" },
                { combo: "CONTROL_SHIFT_ESCAPE", description: "TaskMgr" },
                { combo: "CONTROL_A", description: "Sel All" },
                { combo: "CONTROL_F", description: "Find" },
                { combo: "CONTROL_P", description: "Print" },
                { combo: "CONTROL_L", description: "Align L" },
                { combo: "CONTROL_R", description: "Align R" },
                { combo: "CONTROL_E", description: "Align C" },
                { combo: "CONTROL_D", description: "Dupe" },
                { combo: "CONTROL_G", description: "Group" },
                { combo: "CONTROL_U", description: "Ungrp" },
                { combo: "CONTROL_K", description: "Link" },
                { combo: "CONTROL_H", description: "Replace" },
                { combo: "CONTROL_B", description: "Bold" },
                { combo: "CONTROL_I", description: "Italic" },
                { combo: "CONTROL_U", description: "Undrl" },
                { combo: "ALT_ENTER", description: "Fullscreen" },
                { combo: "SHIFT_ARROW", description: "Nudge" },
                { combo: "SHIFT_SPACEBAR", description: "Cycle Units" },
                { combo: "CONTROL_SPACEBAR", description: "Suggest" },
                { combo: "CONTROL_FORWARD_SLASH", description: "Comment" },
                { combo: "ALT_UP_ARROW", description: "Line Up" },
                { combo: "ALT_DOWN_ARROW", description: "Line Dn" },
                { combo: "SHIFT_ALT_DOWN_ARROW", description: "Copy Line" },
                { combo: "CONTROL_SHIFT_K", description: "Del Line" },
                { combo: "CONTROL_ENTER", description: "Ins Line B" },
                { combo: "CONTROL_SHIFT_ENTER", description: "Ins Line A" },
                { combo: "CONTROL_SHIFT_RIGHT_BRACKET", description: "Jmp Brkt" },
                { combo: "CONTROL_TAB", description: "Next Edit" },
                { combo: "CONTROL_SHIFT_TAB", description: "Prev Edit" },
                { combo: "CONTROL_W", description: "Close Tab" },
                { combo: "CONTROL_ALT_T", description: "Terminal" },
                { combo: "CONTROL_SHIFT_P", description: "Cmd Pal" },
                { combo: "CONTROL_GRAVE_ACCENT", description: "Term Tog" },
                { combo: "CONTROL_B", description: "Side Tog" },
                { combo: "CONTROL_J", description: "Panel Tog" },
                { combo: "CONTROL_SHIFT_E", description: "Explorer" },
                { combo: "CONTROL_SHIFT_F", description: "File Srch" },
                { combo: "CONTROL_SHIFT_G", description: "Git" },
                { combo: "CONTROL_SHIFT_D", description: "Debug" },
                { combo: "CONTROL_SHIFT_X", description: "Extens" },
                { combo: "CONTROL_SHIFT_S", description: "Save As" },
                { combo: "CONTROL_N", description: "New File" },
                { combo: "CONTROL_O", description: "Open File" },
                { combo: "CONTROL_Q", description: "Quit App" },
                { combo: "CONTROL_ALT_DELETE", description: "Force Quit" },
                { combo: "CONTROL_SHIFT", description: "Walk" },
                { combo: "CONTROL_F1", description: "Switch Class" },
                { combo: "ALT_V", description: "View Chg" },
                { combo: "ALT_M", description: "Minimap" },
                { combo: "CONTROL_R", description: "Reload" },
                { combo: "ALT_F4", description: "Close Win" },
                { combo: "CONTROL_Y", description: "Chat" },
                { combo: "CONTROL_G", description: "Gun View" },
                { combo: "CONTROL_T", description: "Anchor" },
                { combo: "CONTROL_SHIFT_M", description: "Model" },
                { combo: "CONTROL_ALT_T", description: "Terrain" },
                { combo: "CONTROL_SHIFT_R", description: "Run" },
                { combo: "CONTROL_SHIFT_T", description: "Test" },
                { combo: "CONTROL_SHIFT_F", description: "Search All" },
                { combo: "CONTROL_SHIFT_D", description: "Download" },
                { combo: "CONTROL_SHIFT_C", description: "Output" },
                { combo: "CONTROL_SHIFT_H", description: "View Exp" },
                { combo: "CONTROL_SHIFT_X", description: "Props" },
                { combo: "CONTROL_SHIFT_E", description: "Toolbox" },
                { combo: "ALT_LEFT_BRACKET", description: "Lyr Back" },
                { combo: "ALT_RIGHT_BRACKET", description: "Lyr Fwd" },
                { combo: "ALT_SHIFT_E", description: "Export" },
            ],
            "MEDIA_CONTROLS": [
                { combo: "VOLUME_INCREMENT", description: "Vol Up" },
                { combo: "VOLUME_DECREMENT", description: "Vol Down" },
                { combo: "MUTE", description: "Mute" },
                { combo: "PLAY_PAUSE", description: "Play/Pse" },
                { combo: "SCAN_PREVIOUS_TRACK", description: "Prev Trk" },
                { combo: "SCAN_NEXT_TRACK", description: "Next Trk" },
            ],
            "MOUSE_ACTIONS": [
                { combo: "MOUSE_BUTTON_1", description: "L Click" },
                { combo: "MOUSE_BUTTON_2", description: "R Click" },
                { combo: "MOUSE_BUTTON_3", description: "M Click" },
                { combo: "MOUSE_WHEEL_UP", description: "Scroll Up" },
                { combo: "MOUSE_WHEEL_DOWN", description: "Scroll Dn" },
                { combo: "ALT_DRAG", description: "Alt Drag" },
                { combo: "SHIFT_DRAG", description: "Shft Drag" },
                { combo: "CONTROL_CLICK", description: "Ctrl Click" },
                { combo: "CONTROL_MIDDLE_CLICK", description: "Ctrl M Click" },
                { combo: "SHIFT_LEFT_CLICK", description: "Shft L Click" },
                { combo: "SHIFT_RIGHT_CLICK", description: "Shft R Click" },
                { combo: "DOUBLE_CLICK", description: "Dbl Click" },
            ],
            "MACROS": [
                { combo: "MACRO_1", description: "Macro 1" },
                { combo: "MACRO_2", description: "Macro 2" },
                { combo: "MACRO_3", description: "Macro 3" },
            ],
            "LAYER_CONTROLS": [
                { combo: "TG_1", description: "Toggle L1" },
                { combo: "MO_1", description: "Moment L1" },
                { combo: "TO_0", description: "To L0" },
            ],
            "SYSTEM_CONTROLS": [
                { combo: "POWER", description: "Power" },
                { combo: "SLEEP", description: "Sleep" },
                { combo: "WAKE", description: "Wake" },
            ],
            "MINECRAFT_SPECIFIC": [
                { combo: "W_KEY", description: "Fwd" },
                { combo: "A_KEY", description: "Left" },
                { combo: "S_KEY", description: "Bck" },
                { combo: "D_KEY", description: "Right" },
                { combo: "DOUBLE_SPACE", description: "Fly Tog" },
                { combo: "NUMBER_HOVER", description: "Hotbar" },
                { combo: "F3_D", description: "Clr Chat" },
                { combo: "F3_N", description: "GM Swch" },
                { combo: "F3_C", description: "Crash" },
                { combo: "F3_A", description: "Reload" },
            ],
            "KICAD_SPECIFIC": [
                { combo: "CONTROL_SCROLL", description: "Zoom" },
                { combo: "ALT_ONE", description: "Lyr Vw 1" },
                { combo: "ALT_TWO", description: "Lyr Vw 2" },
                { combo: "ALT_THREE", description: "Lyr Vw 3" },
                { combo: "ALT_FOUR", description: "Lyr Vw 4" },
                { combo: "ALT_FIVE", description: "Lyr w 5" },
            ],
            "FUSION360_SPECIFIC": [
                { combo: "SHIFT_SCROLL", description: "Pan" },
            ],
        };

        const MIN_LAYERS = 1;
        const MAX_LAYERS = 10;
        const DEFAULT_LAYERS = 2; // Default number of layers for initial load if no profile exists

        // Helper function to create an empty layer object
        // Now accepts gridSize to correctly size the arrays
        const createEmptyLayer = (index, currentGridSize) => ({
            name: `Layer ${index}`,
            labels: Array(currentGridSize * currentGridSize).fill(''),
            keys: Array(currentGridSize * currentGridSize).fill(null),
            macros: [] // Macros are technically global to the app but stored on Layer 0 in JSON
        });

        // Helper function to create a default physical layout based on currentGridSize
        // Now accepts gridSize to correctly size the layout
        const createDefaultPhysicalLayout = (currentGridSize) => {
            const layout = [];
            for (let i = 0; i < currentGridSize * currentGridSize; i++) {
                layout.push({ index: i, row: Math.floor(i / currentGridSize), col: i % currentGridSize });
            }
            return layout;
        };


        // Modal component (formerly from src/components/Modal.js)
        const Modal = ({ show, title, message, onClose }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{title}</h3>
                        {message && <p className="mb-4">{message}</p>}
                        <div className="flex justify-end">
                            <button
                                onClick={onClose}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                OK
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Confirmation Modal (formerly from src/components/ConfirmationModal.js)
        const ConfirmationModal = ({ show, title, message, onConfirm, onCancel }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{title}</h3>
                        {message && <p className="mb-4">{message}</p>}
                        <div className="flex justify-end space-x-4">
                            <button
                                onClick={onCancel}
                                className="bg-zinc-600 hover:bg-zinc-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={onConfirm}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Confirm
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Sidebar component (formerly from src/components/Sidebar.js)
        const Sidebar = ({ activeTab, setActiveTab }) => {
            const { useState, useEffect } = React; // Ensure React hooks are imported within component scope
            return (
                <div className="w-64 bg-zinc-900 p-6 flex flex-col border-r border-zinc-700 shadow-xl">
                    <div className="text-2xl font-bold text-red-500 mb-8">Trkey</div>
                    <nav className="flex-grow">
                        <ul className="space-y-4">
                            <li>
                                <a href="#" onClick={() => setActiveTab('keymap')} className={`flex items-center ${activeTab === 'keymap' ? 'text-red-300' : 'text-zinc-400'} hover:text-red-500 font-semibold text-lg transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path></svg>
                                    KEYMAP
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('layout')} className={`flex items-center ${activeTab === 'layout' ? 'text-red-300' : 'text-zinc-400'} hover:text-red-500 font-semibold text-lg transition-colors duration-200`}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M9 20l-5.447-2.723A1 1 0 013 16.382V5.618a1 1 0 011.553-.894L9 7m0 13l6-3m-6 3V7m6 10l4.447 2.223A1 1 0 0021 18.382V7.618a1 1 0 00-1.553-.894L15 10m0 0V7m0 10.382l-.618.309L12 21l-2.382-1.191L9 20m0-13l2.382 1.191L12 3l2.382 1.191L15 7m0 0V3m0 0l-5.447 2.723A1 1 0 009 5.618V16.382a1 1 0 001.553.894L15 13m0 0V7"/>
                                </svg>
                                    LAYOUT
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('macros')} className={`flex items-center ${activeTab === 'macros' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M12 6.293V4a1 1 0 00-1-1H5a1 1 0 00-1 1v10a1 1 0 001 1h6a1 1 0 001-1v-2.293l1.707 1.707a1 1 0 001.414-1.414l-4-4a1 1 0 00-1.414 0l-4 4a1 1 0 001.414 1.414L10 10.414V12a1 1 0 001 1h2a1 1 0 001-1V8.293l1.707 1.707a1 1 0 001.414-1.414l-4-4z"></path></svg>
                                    MACROS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('save-load')} className={`flex items-center ${activeTab === 'save-load' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z"></path></svg>
                                    SAVE + LOAD
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('settings')} className={`flex items-center ${activeTab === 'settings' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 00-1 1v1a1 1 0 002 0V3a1 1 0 00-1-1zm4 4a1 1 0 011 1v1a1 1 0 01-2 0V7a1 1 0 011-1zM6 6a1 1 0 00-1 1v1a1 1 0 002 0V7a1 1 0 00-1-1zm0 8a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm8 0a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm-4 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zM2 10a1 1 0 001 1h1a1 1 0 000-2H3a1 1 0 00-1 1zm14 0a1 1 0 001 1h1a1 1 0 000-2h-1a1 1 0 00-1 1zM7 10a3 3 0 116 0 3 3 0 01-6 0z"></path></svg>
                                    SETTINGS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('keytester')} className={`flex items-center ${activeTab === 'keytester' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 002 0V3zM14 8a1 1 0 011 1v1a1 1 0 11-2 0V9a1 1 0 011-1zM6 8a1 1 0 00-1 1v1a1 1 0 002 0V9a1 1 0 00-1-1zm0 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm8 0a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm-4 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zM2 10a1 1 0 001 1h1a1 1 0 000-2H3a1 1 0 00-1 1zm14 0a1 1 0 001 1h1a1 1 0 000-2h-1a1 1 0 00-1 1zM7 10a3 3 0 116 0 3 3 0 01-6 0z"></path></svg>
                                    KEY TESTER
                                </a>
                            </li>
                        </ul>
                    </nav>
                </div>
            );
        };

        // KeymapGrid component (formerly from src/components/KeymapGrid.js)
        const KeymapGrid = ({ keymap, handleDrop, handleKeymapDragStart, handleDragEnd, clearKeymapCell, currentLayer, setCurrentLayer, selectedKeymapCell, handleKeymapCellClick, clearCurrentLayer, numLayers, physicalLayout, gridSize }) => {
            const { useState, useEffect } = React;
            // The keymap prop is now an array of layer objects, each with 'keys' and 'labels'
            const NUM_KEYS_IN_GRID = gridSize * gridSize; // Dynamically calculate
            const currentLayerData = keymap[currentLayer] || { keys: Array(NUM_KEYS_IN_GRID).fill(null), labels: Array(NUM_KEYS_IN_GRID).fill('') };

            // Helper to get the key/label for a specific flat index
            const getCellContent = (flatIndex) => {
                // Ensure flatIndex is within bounds for keymap data
                if (flatIndex < 0 || flatIndex >= currentLayerData.keys.length) {
                    return null;
                }

                const keyCombo = currentLayerData.keys[flatIndex];
                const keyLabel = currentLayerData.labels[flatIndex];
                
                if (keyCombo) {
                    // Find the description from presets if available
                    let description = keyLabel; // Default to label
                    for (const category in presets) {
                        const found = presets[category].find(p => p.combo === keyCombo);
                        if (found) {
                            description = found.description;
                            break;
                        }
                    }
                    // For macros, use the macro name as description
                    if (keyCombo.startsWith("MACRO_")) {
                        const macroNum = keyCombo.split('_')[1];
                        // If you want to show the actual macro name, you'd need to pass the macros array here
                        description = `Macro ${macroNum}`;
                    }
                    // Special handling for layer functions
                    if (keyCombo.startsWith("TO(") || keyCombo.startsWith("MO(") || keyCombo.startsWith("TG(")) {
                        description = keyCombo; // Show the function directly
                    }
                    // Special handling for NO_OP
                    if (keyCombo === "NO_OP") {
                        description = "No Operation";
                    }

                    return { combo: keyCombo, description: description };
                }
                return null;
            };

            const gridColsClass = `grid-cols-${gridSize}`; // Dynamically set grid columns using the prop

            return (
                <div className="flex flex-col items-center">
                    <div className="flex flex-wrap justify-center gap-2 mb-4"> {/* Use flex-wrap for responsiveness */}
                        {[...Array(numLayers)].map((_, index) => ( // Render buttons based on numLayers
                            <button
                                key={`layer-btn-${index}`}
                                onClick={() => setCurrentLayer(index)}
                                className={`px-4 py-2 rounded-lg font-semibold transition-colors duration-200
                                            ${currentLayer === index ? 'bg-red-600 text-white shadow-md' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}
                            >
                                Layer {index}
                            </button>
                        ))}
                        <button
                            onClick={clearCurrentLayer}
                            className="px-4 py-2 rounded-lg font-semibold bg-red-800 text-white hover:bg-red-700 transition-colors duration-200 shadow-md"
                            title="Clear all keys on the current layer"
                        >
                            Clear Current Layer
                        </button>
                    </div>
                    {/* Render keys based on physicalLayout */}
                    <div className={`grid ${gridColsClass} gap-4 mb-12 w-full max-w-2xl mx-auto`}> {/* Use gridColsClass and increased max-width */}
                        {/* Generate all possible grid cells first, then map physical layout onto them */}
                        {Array.from({ length: gridSize * gridSize }).map((_, globalGridIndex) => {
                            const row = Math.floor(globalGridIndex / gridSize);
                            const col = globalGridIndex % gridSize;
                            
                            // Check if this global grid index corresponds to an active key in physicalLayout
                            const layoutItem = physicalLayout.find(item => item && item.row === row && item.col === col);
                            
                            const flatIndex = layoutItem ? layoutItem.index : null; // Get the flat index if it's an active key
                            const cellContent = flatIndex !== null ? getCellContent(flatIndex) : null;

                            // Determine if this is an active key cell or a placeholder
                            const isActiveKeyCell = flatIndex !== null;

                            return (
                                <div
                                    key={`grid-cell-${globalGridIndex}`} /* Unique key for each display cell */
                                    className={`relative rounded-xl p-4 h-32 flex flex-col items-center justify-center border-2 shadow-md
                                                ${isActiveKeyCell 
                                                    ? `bg-zinc-700 hover:border-red-500 transition-all duration-200 cursor-pointer ${selectedKeymapCell && selectedKeymapCell.index === flatIndex && selectedKeymapCell.layer === currentLayer ? 'border-blue-500 ring-2 ring-blue-500 bg-blue-900 bg-opacity-30' : 'border-zinc-600'}`
                                                    : 'bg-zinc-800 border-zinc-700'
                                                }`}
                                    onDragOver={(e) => { if (isActiveKeyCell) e.preventDefault(); }} /* Only allow drop on active keys */
                                    onDrop={(e) => { if (isActiveKeyCell) handleDrop(e, flatIndex); }} /* Pass flatIndex for active keys */
                                    draggable={isActiveKeyCell} /* Only draggable if it's an active key */
                                    onDragStart={(e) => { if (isActiveKeyCell) handleKeymapDragStart(e, cellContent, flatIndex); }}
                                    onDragEnd={handleDragEnd}
                                    onClick={() => { if (isActiveKeyCell) handleKeymapCellClick(flatIndex, currentLayer); }}
                                >
                                    {isActiveKeyCell ? (
                                        cellContent ? (
                                            <>
                                                <span className="text-2xl font-bold text-red-300">{cellContent.combo}</span>
                                                <span className="text-sm text-zinc-400 text-center mt-1">{cellContent.description}</span>
                                            </>
                                        ) : (
                                            <span className="text-zinc-500">Drag & Drop Here</span>
                                        )
                                    ) : (
                                        <span className="text-zinc-600 text-sm">Empty Slot</span>
                                    )}
                                    {isActiveKeyCell && cellContent && (
                                        <button
                                            onClick={(e) => { e.stopPropagation(); clearKeymapCell(flatIndex); }}
                                            className="absolute top-1 right-1 text-zinc-400 hover:text-red-500 text-sm p-1 rounded-full bg-zinc-600 hover:bg-zinc-500 transition-colors"
                                            title="Clear cell"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ShortcutPool component (formerly from src/components/ShortcutPool.js)
        const ShortcutPool = ({ shortcutPool, draggedShortcut, handleShortcutDragStart, handleDragEnd, selectedKeymapCell, handleShortcutClick }) => {
            const { useState, useEffect, useMemo } = React; // Added useMemo
            const [searchTerm, setSearchTerm] = useState('');
            // Initialize selectedCategory to the first key in shortcutPool
            const [selectedCategory, setSelectedCategory] = useState(Object.keys(shortcutPool)[0]);

            // Filter shortcuts based on selected category and search term
            const filteredShortcuts = useMemo(() => {
                if (!selectedCategory) return []; // No category selected yet

                const categoryShortcuts = shortcutPool[selectedCategory] || [];
                if (!searchTerm) return categoryShortcuts;

                const lowerCaseSearchTerm = searchTerm.toLowerCase();
                return categoryShortcuts.filter(shortcut =>
                    shortcut.combo.toLowerCase().includes(lowerCaseSearchTerm) ||
                    shortcut.description.toLowerCase().includes(lowerCaseSearchTerm)
                );
            }, [searchTerm, selectedCategory, shortcutPool]);

            return (
                <div className="flex flex-col md:flex-row w-full bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-hidden">
                    {/* Left Sidebar for Categories */}
                    <div className="w-full md:w-1/4 bg-zinc-900 p-4 custom-scrollbar overflow-y-auto border-r border-zinc-700">
                        <h3 className="text-xl font-semibold text-red-300 mb-4">Categories</h3>
                        <ul className="space-y-2">
                            {Object.keys(shortcutPool).map(category => (
                                <li key={category}>
                                    <button
                                        onClick={() => setSelectedCategory(category)}
                                        className={`w-full text-left px-4 py-2 rounded-lg transition-colors duration-200
                                                    ${selectedCategory === category ? 'bg-red-600 text-white font-bold' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}
                                    >
                                        {category}
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>

                    {/* Right Main Content Area for Search and Shortcuts */}
                    <div className="flex-1 flex flex-col p-4">
                        {/* Search Bar */}
                        <div className="relative w-full mb-6">
                            <input
                                type="text"
                                placeholder="Search shortcuts..."
                                className="w-full p-3 pl-10 rounded-xl bg-zinc-700 text-white border border-zinc-600 focus:border-red-500 focus:ring-1 focus:ring-red-500 transition-all duration-200"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-zinc-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd"></path></svg>
                        </div>

                        {/* Shortcuts Grid */}
                        <div className="flex-1 grid grid-cols-2 md:grid-cols-3 gap-4 custom-scrollbar overflow-y-auto pr-2">
                            {filteredShortcuts.length > 0 ? (
                                filteredShortcuts.map((shortcut, sIdx) => (
                                    <div
                                        key={`${selectedCategory}-${sIdx}`} // Ensure unique key
                                        className={`bg-zinc-600 rounded-lg p-3 flex flex-col items-center justify-center cursor-pointer text-center /* Changed cursor to pointer */
                                                    ${draggedShortcut === shortcut ? 'opacity-50 border-red-500 border-2' : 'border-2 border-zinc-600'}
                                                    ${selectedKeymapCell ? 'hover:bg-blue-700 hover:border-blue-400' : 'hover:bg-zinc-500 hover:border-red-400'} /* Conditional hover */
                                                    transition-all duration-200`}
                                        draggable
                                        onDragStart={(e) => handleShortcutDragStart(e, shortcut)}
                                        onDragEnd={handleDragEnd}
                                        onClick={() => handleShortcutClick(shortcut)} /* Added onClick */
                                    >
                                        <span className="font-medium text-lg">{shortcut.combo}</span>
                                        <span className="text-sm text-zinc-300">{shortcut.description}</span>
                                        {selectedKeymapCell && (
                                            <button
                                                onClick={(e) => { e.stopPropagation(); handleShortcutClick(shortcut); }}
                                                className="mt-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Assign
                                            </button>
                                        )}
                                    </div>
                                ))
                            ) : (
                                <p className="text-zinc-400 text-lg col-span-full text-center">No shortcuts found in "{selectedCategory}" matching "{searchTerm}".</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // MacroManagement component (formerly from src/components/MacroManagement.js)
        const MacroManagement = ({ macros, addMacro, editMacro, deleteMacro }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">MACRO MANAGEMENT</h1>
                    <button
                        onClick={addMacro}
                        className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold mb-8"
                    >
                        Add New Macro
                    </button>

                    {macros.length === 0 ? (
                        <p className="text-zinc-400 text-lg">No macros defined yet. Click "Add New Macro" to create one.</p>
                    ) : (
                        <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                            <h2 className="text-2xl font-bold text-red-300 mb-4">Defined Macros</h2>
                            <ul className="space-y-4">
                                {macros.map(macro => (
                                    <li key={macro.id} className="bg-zinc-600 rounded-lg p-4 flex flex-col sm:flex-row justify-between items-start sm:items-center shadow-md border border-zinc-500">
                                        <div>
                                            <p className="text-xl font-semibold text-white">{macro.name}</p>
                                            <p className="text-zinc-300 text-sm break-all">Sequence: "{macro.sequence}"</p>
                                        </div>
                                        <div className="flex space-x-3 mt-3 sm:mt-0">
                                            <button
                                                onClick={() => editMacro(macro.id)}
                                                className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Edit
                                            </button>
                                            <button
                                                onClick={() => deleteMacro(macro.id)}
                                                className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Delete
                                            </button>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
            );
        };

        // SaveLoad component (formerly from src/components/SaveLoad.js)
        const SaveLoad = ({ saveProfile, loadProfile, exportKeymap, uploadToDevice, isConnected, handleConnectPico, handleGetFile, handleDeleteFile, logs, clearLogs, showLogDropdown, toggleLogDropdown }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full p-8"> {/* Added padding here */}
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">SAVE & LOAD PROFILE</h1>
                    <div className="flex flex-col space-y-4 w-full max-w-md">
                        <button
                            onClick={saveProfile}
                            className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Save Profile to Browser
                        </button>
                        <button
                            onClick={loadProfile}
                            className="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Load Profile from Browser
                        </button>
                        <button
                            onClick={exportKeymap}
                            className="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Export Configuration as layers.json
                        </button>
                        <div className="bg-zinc-700 rounded-xl p-4 text-zinc-300 text-center text-sm border border-zinc-600">
                            To upload to Pico: Save the exported `layers.json` file, then drag and drop it onto your `CIRCUITPY` drive.
                        </div>
                        <h2 className="text-2xl font-bold text-red-300 mt-8 mb-4">Device Operations (Web Serial)</h2>
                        {!isConnected ? (
                            <button
                                onClick={handleConnectPico}
                                className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                            >
                                Connect to Device
                            </button>
                        ) : (
                            <>
                                <p className="text-green-400 text-center text-lg font-semibold">Connected to Pico!</p>
                                <button
                                    onClick={uploadToDevice}
                                    className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                                >
                                    Upload layers.json to Device
                                </button>
                                <button
                                    onClick={() => handleGetFile("layers.json")}
                                    className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                                >
                                    Check layers.json on Device
                                </button>
                                <button
                                    onClick={() => handleDeleteFile("layers.json")}
                                    className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                                >
                                    Delete layers.json on Device
                                </button>
                            </>
                        )}

                        {/* Log Display Dropdown */}
                        <div className="mt-8 w-full">
                            <button
                                onClick={toggleLogDropdown}
                                className="w-full bg-zinc-600 hover:bg-zinc-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold flex justify-between items-center"
                            >
                                Show Device Log
                                <svg className={`w-5 h-5 transition-transform duration-200 ${showLogDropdown ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            {showLogDropdown && (
                                <div className="bg-zinc-700 rounded-xl p-4 mt-4 shadow-lg border border-zinc-600">
                                    <textarea
                                        readOnly
                                        value={logs.join('\n')}
                                        className="w-full h-48 bg-zinc-800 border border-zinc-600 rounded-md p-3 text-white font-mono text-sm resize-y custom-scrollbar"
                                        placeholder="Device log messages will appear here..."
                                    ></textarea>
                                    <button
                                        onClick={clearLogs}
                                        className="mt-3 bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200 text-sm font-semibold w-full"
                                    >
                                        Clear Log
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // NEW: Component to display the physical layout JSON
        const PhysicalLayoutViewer = ({ physicalLayout }) => {
            const { useState, useEffect } = React;
            const [layoutJson, setLayoutJson] = useState('');

            useEffect(() => {
                try {
                    setLayoutJson(JSON.stringify(physicalLayout, null, 2));
                } catch (e) {
                    setLayoutJson("Error displaying layout JSON.");
                }
            }, [physicalLayout]);

            return (
                <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 mt-8">
                    <h2 className="text-2xl font-bold text-red-300 mb-4">Current Physical Layout (from Application State)</h2>
                    <p className="text-zinc-400 mb-2 text-sm">This shows the layout currently applied to the UI. To change it, modify the grid above or import a full JSON configuration in the Settings tab that includes a "physical_layout" array.</p>
                    <textarea
                        readOnly
                        className="w-full h-64 bg-zinc-800 border border-zinc-600 rounded-md p-4 text-white font-mono text-sm resize-y custom-scrollbar"
                        value={layoutJson}
                    ></textarea>
                </div>
            );
        };

        // Settings component (formerly from src/components/Settings.js)
        const Settings = ({ jsonInput, setJsonInput, loadConfigFromJson, numLayers, setNumLayers }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full p-8"> {/* Added padding here */}
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">SETTINGS</h1>
                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                        <h2 className="text-2xl font-bold text-red-300 mb-4">Layer Configuration</h2>
                        <div className="flex items-center justify-between mb-6">
                            <label htmlFor="num-layers" className="text-lg text-zinc-200 mr-4">Number of Layers:</label>
                            <input
                                type="number"
                                id="num-layers"
                                value={numLayers}
                                onChange={(e) => {
                                    const value = parseInt(e.target.value);
                                    if (!isNaN(value)) {
                                        setNumLayers(Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, value)));
                                    }
                                }}
                                min={MIN_LAYERS}
                                max={MAX_LAYERS}
                                className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-24 text-white text-center"
                            />
                        </div>

                        <h2 className="text-2xl font-bold text-red-300 mb-4">Import JSON Configuration</h2>
                        <textarea
                            className="w-full h-64 bg-zinc-800 border border-zinc-600 rounded-md p-4 text-white font-mono text-sm resize-y"
                            placeholder="Paste your full Trkey configuration JSON here, including 'physical_layout' and 'layers'..."
                            value={jsonInput}
                            onChange={(e) => setJsonInput(e.target.value)}
                        ></textarea>
                        <button
                            onClick={() => loadConfigFromJson(jsonInput)}
                            className="mt-4 bg-teal-600 hover:bg-teal-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full"
                        >
                            Load JSON
                        </button>
                    </div>
                </div>
            );
        };

        // KeyTester component (formerly from src/components/KeyTester.js)
        const KeyTester = ({ activeTab }) => {
            const { useState, useEffect } = React;
            const [pressedKeys, setPressedKeys] = useState([]);
            const [modifierState, setModifierState] = useState({
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                metaKey: false, // Windows key or Command key on Mac
            });

            useEffect(() => {
                if (activeTab === 'keytester') {
                    const handleKeyDown = (e) => {
                        e.preventDefault(); // Prevent default browser actions for keys
                        setPressedKeys(prev => {
                            const newKey = { key: e.key, code: e.code, timestamp: Date.now() };
                            // Only add if not already present to avoid duplicates for held keys
                            if (!prev.some(k => k.code === e.code)) {
                                return [...prev, newKey];
                            }
                            return prev;
                        });
                        setModifierState({
                            ctrlKey: e.ctrlKey,
                            shiftKey: e.shiftKey,
                            altKey: e.altKey,
                            metaKey: e.metaKey,
                        });
                    };

                    const handleKeyUp = (e) => {
                        e.preventDefault();
                        setPressedKeys(prev => prev.filter(k => k.code !== e.code));
                        setModifierState({
                            ctrlKey: e.ctrlKey,
                            shiftKey: e.shiftKey,
                            altKey: e.altKey,
                            metaKey: e.metaKey,
                        });
                    };

                    window.addEventListener('keydown', handleKeyDown);
                    window.addEventListener('keyup', handleKeyUp);

                    return () => {
                        window.removeEventListener('keydown', handleKeyDown);
                        window.removeEventListener('keyup', handleKeyUp);
                    };
                } else {
                    setPressedKeys([]);
                    setModifierState({
                        ctrlKey: false,
                        shiftKey: false,
                        altKey: false,
                        metaKey: false,
                    });
                }
            }, [activeTab]);

            const clearPressedKeys = () => {
                setPressedKeys([]);
                setModifierState({
                    ctrlKey: false,
                    shiftKey: false,
                    altKey: false,
                    metaKey: false,
                });
            };

            return (
                <div className="flex flex-col items-center w-full p-8">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">KEY TESTER</h1>
                    <p className="text-zinc-300 mb-6 text-lg text-center">Press any key on your keyboard to see its details and active modifiers.</p>

                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 min-h-[250px] flex flex-col items-center">
                        <div className="flex justify-center space-x-4 mb-6 w-full">
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.ctrlKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Ctrl</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.shiftKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Shift</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.altKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Alt</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.metaKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Meta (Win/Cmd)</span>
                        </div>

                        <div className="flex-1 flex flex-wrap items-center justify-center gap-4 w-full">
                            {pressedKeys.length === 0 ? (
                                <p className="text-zinc-400 text-xl">No keys pressed...</p>
                            ) : (
                                pressedKeys.map((keyInfo, index) => (
                                    <div
                                        key={keyInfo.code + '-' + keyInfo.timestamp}
                                        className="bg-zinc-600 rounded-lg p-4 shadow-md border border-zinc-500 flex flex-col items-center justify-center min-w-[120px] transform transition-transform duration-100 hover:scale-105"
                                    >
                                        <span className="text-xl font-bold text-red-300">{keyInfo.key === ' ' ? 'Space' : keyInfo.key === '' ? 'Unknown' : keyInfo.key}</span>
                                        <span className="text-sm text-zinc-400 mt-1">{keyInfo.code}</span>
                                    </div>
                                ))
                            )}
                        </div>
                        <button
                            onClick={clearPressedKeys}
                            className="mt-6 bg-red-600 hover:bg-red-700 px-6 py-2 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Clear Pressed Keys
                        </button>
                    </div>
                </div>
            );
        };

        {/* Renamed MappingPage to LayoutPage */}
        const LayoutPage = ({ gridSize, setGridSize, physicalLayout, setPhysicalLayout, keymap, setKeymap, exportKeymap, uploadToDevice, isConnected, handleConnectPico, webSerialSupported }) => {
            const { useState, useEffect } = React;

            // Effect to update physicalLayout when gridSize changes
            useEffect(() => {
                // When gridSize changes, regenerate a default physical layout if the current layout doesn't match
                const numExpectedKeys = gridSize * gridSize;
                // Check if current physicalLayout needs to be adjusted based on new gridSize
                // This is a robust check: filter out invalid items, then check if length matches expected,
                // and if all items are within the new grid bounds.
                const currentValidPhysicalLayout = physicalLayout.filter(item => 
                    item && typeof item.index === 'number' && item.row < gridSize && item.col < gridSize
                );

                if (currentValidPhysicalLayout.length !== numExpectedKeys || currentValidPhysicalLayout.some(item => !item)) {
                    // Only regenerate if the existing layout is not a perfect grid
                    const newLayout = createDefaultPhysicalLayout(gridSize);
                    setPhysicalLayout(newLayout);
                    // Also ensure keymap layers are correctly sized
                    setKeymap(prevKeymap => prevKeymap.map((layer, lIdx) => {
                        const newKeys = Array(numExpectedKeys).fill(null);
                        const newLabels = Array(numExpectedKeys).fill('');
                        // Copy existing keys/labels up to the new size and ensure they align with the new default physical layout
                        newLayout.forEach(layoutItem => {
                            if (layoutItem && layoutItem.index < (layer.keys ? layer.keys.length : 0)) {
                                newKeys[layoutItem.index] = layer.keys[layoutItem.index];
                                newLabels[layoutItem.index] = layer.labels[layoutItem.index];
                            }
                        });
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }));
                } else {
                    // If gridSize changed but the existing layout is still valid for the new gridSize,
                    // just update keymap sizes to match the new gridSize.
                    setKeymap(prevKeymap => prevKeymap.map((layer, lIdx) => {
                        const newKeys = Array(numExpectedKeys).fill(null);
                        const newLabels = Array(numExpectedKeys).fill('');
                        // Copy existing keys/labels, ensuring they fit the new grid size
                        physicalLayout.forEach(layoutItem => { // Use the (potentially original) physicalLayout
                            if (layoutItem && layoutItem.index < (layer.keys ? layer.keys.length : 0) && layoutItem.index < numExpectedKeys) {
                                newKeys[layoutItem.index] = layer.keys[layoutItem.index];
                                newLabels[layoutItem.index] = layer.labels[layoutItem.index];
                            }
                        });
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }));
                }
            }, [gridSize, physicalLayout]); // physicalLayout dependency is needed to correctly adapt keymap when layout is changed directly.


            const toggleKeyActive = (row, col) => {
                const newPhysicalLayout = [...physicalLayout];
                const flatIndex = row * gridSize + col;

                // Check if a key at this logical position (row, col) already exists in physicalLayout
                // We need to check based on row/col because flatIndex might change if grid size changes,
                // but row/col is the stable position in the visual grid.
                const existingKeyIndexInArray = newPhysicalLayout.findIndex(item => item && item.row === row && item.col === col);

                if (existingKeyIndexInArray !== -1) {
                    // Key exists, so make it inactive (remove it from the array)
                    newPhysicalLayout.splice(existingKeyIndexInArray, 1);
                } else {
                    // Key does not exist, so add it. Assign the current flatIndex as its index.
                    newPhysicalLayout.push({ index: flatIndex, row: row, col: col });
                }

                // Re-sort the layout by index to maintain consistency for how it's consumed by KeymapGrid
                newPhysicalLayout.sort((a, b) => a.index - b.index);
                setPhysicalLayout(newPhysicalLayout);

                // Also, clear the corresponding keymap entry for this specific flat index if the physical key is removed
                if (existingKeyIndexInArray !== -1) {
                    setKeymap(prevKeymap => prevKeymap.map(layer => {
                        const newKeys = [...layer.keys];
                        const newLabels = [...layer.labels];
                        // Only clear if the flatIndex is valid for the current keymap size
                        if (flatIndex < newKeys.length) { 
                            newKeys[flatIndex] = null;
                            newLabels[flatIndex] = '';
                        }
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }));
                }
            };

            const gridColsClass = `grid-cols-${gridSize}`;

            return (
                <div className="flex flex-col items-center w-full p-8">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">KEYBOARD LAYOUT CONFIGURATION</h1>
                    <p className="text-zinc-300 mb-6 text-lg text-center">Define the physical layout of your macropad. Click on cells to toggle them between active key positions and empty slots. Active keys (red background) will be included in your physical layout. Empty slots (darker background) will not be part of your Trkey's layout.</p>
                    
                    {/* Grid Size Configuration - Moved from Settings */}
                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 mb-8">
                        <h2 className="text-2xl font-bold text-red-300 mb-4">Grid Dimensions</h2>
                        <div className="flex items-center justify-between mb-6">
                            <label htmlFor="grid-size" className="text-lg text-zinc-200 mr-4">Grid Size (2x2 to 5x5):</label>
                            <input
                                type="number"
                                id="grid-size"
                                value={gridSize}
                                onChange={(e) => {
                                    const value = parseInt(e.target.value);
                                    if (!isNaN(value)) {
                                        setGridSize(Math.max(MIN_GRID_SIZE, Math.min(MAX_GRID_SIZE, value)));
                                    }
                                }}
                                min={MIN_GRID_SIZE}
                                max={MAX_GRID_SIZE}
                                className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-24 text-white text-center"
                            />
                        </div>
                    </div>

                    <div className={`grid ${gridColsClass} gap-4 w-full max-w-2xl mx-auto mb-8`}>
                        {Array.from({ length: gridSize * gridSize }).map((_, i) => {
                            const row = Math.floor(i / gridSize);
                            const col = i % gridSize;
                            // Check if this cell is part of the active physical layout
                            const isActive = physicalLayout.some(item => item && item.row === row && item.col === col);

                            return (
                                <div
                                    key={`layout-cell-${row}-${col}`}
                                    className={`relative h-32 flex flex-col items-center justify-center rounded-xl p-4 shadow-md border-2
                                                ${isActive ? 'bg-red-800 border-red-600 text-white cursor-pointer hover:bg-red-700' : 'bg-zinc-800 border-zinc-700 text-zinc-500 cursor-pointer hover:bg-zinc-700'}
                                                transition-all duration-200`}
                                    onClick={() => toggleKeyActive(row, col)}
                                >
                                    <span className="text-3xl font-bold">{i}</span> {/* Display flat index */}
                                    <span className="text-sm">({row}, {col})</span> {/* Display row, col */}
                                    {isActive ? (
                                        <span className="absolute bottom-2 text-xs font-semibold text-red-200">ACTIVE KEY</span>
                                    ) : (
                                        <span className="absolute bottom-2 text-xs font-semibold text-zinc-400">EMPTY SLOT</span>
                                    )}
                                </div>
                            );
                        })}
                    </div>

                    <div className="w-full max-w-2xl text-center text-zinc-400 text-sm mb-8">
                        The numbers (0, 1, 2...) displayed in each cell represent its **logical index** within the grid. When a cell is an **ACTIVE KEY**, this index will correspond to its position in the `physical_layout` array and the `keys` and `labels` arrays of each layer in the generated JSON.
                    </div>

                    {/* New Buttons for Upload/Download */}
                    <div className="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 w-full max-w-2xl">
                        <button
                            onClick={exportKeymap}
                            className="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full sm:w-1/2"
                        >
                            Download Layout JSON
                        </button>
                        {!isConnected ? (
                             <button
                                onClick={handleConnectPico}
                                className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full sm:w-1/2"
                                title={!webSerialSupported ? "Web Serial API not supported by your browser." : "Connect to your macropad via Web Serial."}
                                disabled={!webSerialSupported}
                            >
                                {webSerialSupported ? 'Connect to Macropad' : 'Web Serial Not Supported'}
                            </button>
                        ) : (
                            <button
                                onClick={uploadToDevice}
                                className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full sm:w-1/2"
                            >
                                Upload Layout to Macropad
                            </button>
                        )}
                    </div>
                     {!webSerialSupported && (
                        <p className="text-red-300 text-sm mt-4 text-center">
                            *Web Serial API is required for direct device interaction and is best supported in Chromium-based browsers (e.g., Chrome, Edge).
                        </p>
                    )}

                    {/* Add the PhysicalLayoutViewer component here */}
                    <PhysicalLayoutViewer physicalLayout={physicalLayout} />
                </div>
            );
        };


        // Main App component (formerly from src/App.js)
        function App() {
            const { useState, useEffect, useCallback } = React;

            // Web Serial state
            const [port, setPort] = useState(null);
            const [reader, setReader] = useState(null);
            const [writer, setWriter] = useState(null);
            const [isConnected, setIsConnected] = useState(false);
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();

            // Log state
            const [logs, setLogs] = useState([]);
            const [showLogDropdown, setShowLogDropdown] = useState(false);
            const [isLoadingDeviceConfig, setIsLoadingDeviceConfig] = useState(false); // New loading state


            const addLog = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogs(prevLogs => [`[${timestamp}] [${type.toUpperCase()}] ${message}`, ...prevLogs].slice(0, 50)); // Keep last 50 logs
            };

            const clearLogs = () => {
                setLogs([]);
            };

            const toggleLogDropdown = () => {
                setShowLogDropdown(prev => !prev);
            };

            // Web Serial Utility Functions
            const connectPico = async () => {
                try {
                    addLog("Attempting to connect to Pico...", "info");
                    setIsLoadingDeviceConfig(true); // Start loading indicator
                    const selectedPort = await navigator.serial.requestPort();
                    await selectedPort.open({ baudRate: 115200 });
                    const newWriter = selectedPort.writable.getWriter();
                    const newReader = selectedPort.readable.getReader();

                    setPort(selectedPort);
                    setWriter(newWriter);
                    setReader(newReader);
                    setIsConnected(true);
                    
                    setModalContent({
                        title: "Connection Successful",
                        message: "Successfully connected to Pico! Attempting to load existing configuration..."
                    });
                    setShowModal(true);
                    addLog("Successfully connected to Pico!", "success");

                    // *** AUTOMATICALLY LOAD CONFIG FROM DEVICE ***
                    try {
                        const fileContentBlob = await getFile("layers.json");
                        const fileContentText = await fileContentBlob.text();
                        loadConfigFromJson(fileContentText, "fromDevice"); // Use the refactored load function
                        setModalContent(prev => ({ ...prev, message: "Connected and loaded configuration from device!" }));
                        addLog("Configuration loaded automatically from device.", "success");
                    } catch (fileError) {
                        setModalContent(prev => ({ ...prev, message: `Connected to Pico, but failed to load layers.json: ${fileError.message}. Starting with default configuration.` }));
                        addLog(`Failed to load layers.json from device: ${fileError.message}.`, "warn");
                    }

                    // Listen for disconnect
                    selectedPort.addEventListener('disconnect', () => {
                        setIsConnected(false);
                        setPort(null);
                        setReader(null);
                        setWriter(null);
                        setModalContent({
                            title: "Disconnected",
                            message: "Pico disconnected."
                        });
                        addLog("Pico disconnected.", "warn");
                        setShowModal(true);
                    });

                } catch (error) {
                    setIsConnected(false);
                    setModalContent({
                        title: "Connection Failed",
                        message: "Failed to connect to Pico: " + error.message
                    });
                    addLog(`Failed to connect to Pico: ${error.message}`, "error");
                } finally {
                    setIsLoadingDeviceConfig(false); // End loading indicator
                    setShowModal(true); // Ensure modal is shown with final status
                }
            };

            // Send a command (LIST, DEL filename, etc.)
            const sendCommand = async (cmd) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot send command.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Sending command: ${cmd}`, "info");
                await writer.write(encoder.encode(cmd + "\n"));
            };

            // Read response until <END> or <EOF>
            const readResponse = async (until = "<END>") => {
                let out = "";
                while (true) {
                    const { value, done } = await reader.read(); // Destructure done as well
                    if (done || !value) break; // Check for done
                    const text = decoder.decode(value);
                    out += text;
                    if (out.includes(until)) break;
                }
                addLog(`Received response (until '${until}'):\n${out}`, "info");
                return out;
            };

            // Upload a file to Pico
            const putFile = async (file) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot upload file.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Initiating upload for ${file.name}...`, "info");
                await sendCommand("PUT " + file.name);
                await new Promise(r => setTimeout(r, 100)); // Small delay for Pico to process command

                const buf = new Uint8Array(await file.arrayBuffer());
                const chunkSize = 256;
                for (let i = 0; i < buf.length; i += chunkSize) {
                    await writer.write(buf.slice(i, i + chunkSize));
                    await new Promise(r => setTimeout(r, 1)); // Small delay between chunks
                }
                await writer.write(encoder.encode("<EOF>"));
                addLog(`Uploaded ${file.name} chunks. Waiting for Pico confirmation.`, "info");
                // Read the confirmation from Pico
                const response = await readResponse("<END>"); // Expect <END> from Pico after successful PUT
                addLog(`Pico PUT response: ${response}`, "info");
            };

            // Download file from Pico (modified to not trigger download, just return content)
            const getFile = async (filename) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot get file.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Initiating request for ${filename}...`, "info");
                await sendCommand("GET " + filename);
                
                // Pico sends <START><size><content><EOF>
                let header = "";
                let contentBytes = new Uint8Array();
                let startedReceiving = false;
                let expectedSize = -1;
                const buffer = []; // Use an array for chunks

                while (true) {
                    const { value, done } = await reader.read();
                    if (done || !value) break;

                    buffer.push(value); // Store Uint8Array chunks

                    // Try to decode and find start marker and size
                    if (!startedReceiving) {
                        const currentText = decoder.decode(new Uint8Array(buffer.flat())); // Decode accumulated parts
                        const startIndex = currentText.indexOf("<START>");
                        if (startIndex !== -1) {
                            const sizeEndIndex = currentText.indexOf(">", startIndex + "<START>".length);
                            if (sizeEndIndex !== -1) {
                                header = currentText.substring(startIndex + "<START>".length, sizeEndIndex);
                                expectedSize = parseInt(header, 10);
                                if (!isNaN(expectedSize)) {
                                    startedReceiving = true;
                                    addLog(`GET response header: ${header}, expected size: ${expectedSize} bytes.`, "info");
                                    // Remove the header part from the buffer for pure content
                                    const headerLength = sizeEndIndex + 1; // Include the '>'
                                    let bytesReadForHeader = 0;
                                    for(let i = 0; i < buffer.length; i++) {
                                        if (bytesReadForHeader + buffer[i].length >= headerLength) {
                                            const remaining = headerLength - bytesReadForHeader;
                                            buffer[i] = buffer[i].slice(remaining);
                                            break;
                                        }
                                        bytesReadForHeader += buffer[i].length;
                                        buffer[i] = new Uint8Array(); // Clear fully consumed chunks
                                    }
                                    buffer = buffer.filter(chunk => chunk.length > 0); // Remove empty chunks
                                }
                            }
                        }
                    }

                    if (startedReceiving) {
                        // Check for <EOF> at the end of the content
                        const combinedBuffer = new Uint8Array(buffer.flat());
                        const eofIndex = decoder.decode(combinedBuffer).indexOf("<EOF>");
                        if (eofIndex !== -1) {
                            contentBytes = combinedBuffer.slice(0, eofIndex);
                            addLog(`Received <EOF>. Total content bytes: ${contentBytes.length}.`, "info");
                            break;
                        }
                    }
                }
                
                if (expectedSize !== -1 && contentBytes.length !== expectedSize) {
                    addLog(`Received size mismatch! Expected ${expectedSize} bytes, got ${contentBytes.length} bytes for ${filename}.`, "error");
                    throw new Error(`File transfer error: Size mismatch for ${filename}.`);
                }

                const blob = new Blob([contentBytes]);
                addLog(`Received content for ${filename}.`, "success");
                return blob; // Return blob to allow further processing (e.g., loading into textarea)
            };

            // Delete a file
            const deleteFile = async (fname) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot delete file.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Attempting to delete ${fname}...`, "info");
                await sendCommand("DEL " + fname);
                const response = await readResponse("<END>"); // Pico should send <END>
                addLog(`Delete response for ${fname}: ${response}`, "info");
            };

            // State for the current grid size (e.g., 3 for 3x3, 4 for 4x4)
            const [gridSize, setGridSize] = useState(DEFAULT_GRID_SIZE);

            // State for the physical layout of the keys
            const [physicalLayout, setPhysicalLayout] = useState(() => createDefaultPhysicalLayout(DEFAULT_GRID_SIZE));
            
            // State for number of layers
            const [numLayers, setNumLayers] = useState(DEFAULT_LAYERS);

            // State for the keymap, initialized based on numLayers and gridSize
            const [keymap, setKeymap] = useState(() => Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i, DEFAULT_GRID_SIZE)));
            
            // Effect to update keymap when numLayers or gridSize changes
            useEffect(() => {
                const numKeysInCurrentGrid = gridSize * gridSize;
                setKeymap(prevKeymap => {
                    const newKeymap = Array(numLayers).fill().map((_, i) => {
                        if (prevKeymap[i]) {
                            // Ensure the existing layer is expanded/shrunk to the new numKeysInCurrentGrid size
                            const currentKeys = prevKeymap[i].keys || [];
                            const currentLabels = prevKeymap[i].labels || [];

                            const keys = Array(numKeysInCurrentGrid).fill(null);
                            const labels = Array(numKeysInCurrentGrid).fill('');

                            // Copy existing keys/labels up to the new size
                            // Only copy if the physical layout supports this index
                            physicalLayout.forEach(layoutItem => {
                                if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < currentKeys.length) {
                                    keys[layoutItem.index] = currentKeys[layoutItem.index];
                                    labels[layoutItem.index] = currentLabels[layoutItem.index];
                                }
                            });

                            return { ...prevKeymap[i], keys: keys, labels: labels };
                        } else {
                            return createEmptyLayer(i, gridSize); // Create new empty layer with correct grid size
                        }
                    });
                    return newKeymap;
                });

                // Adjust currentLayer if it's out of bounds
                setCurrentLayer(prevCurrentLayer => {
                    if (prevCurrentLayer >= numLayers) {
                        return numLayers > 0 ? numLayers - 1 : 0; // Go to last layer or 0 if no layers (min is 1 so never 0)
                    }
                    return prevCurrentLayer;
                });
                addLog(`Number of layers changed to ${numLayers} or grid size changed to ${gridSize}.`, "info");
            }, [numLayers, gridSize, physicalLayout]); // Depend on physicalLayout as well

            const [shortcutPool, setShortcutPool] = useState(Object.fromEntries(Object.entries(presets).map(([k, v]) => [k, [...v]])));
            const [showModal, setShowModal] = useState(false);
            const [modalContent, setModalContent] = useState({ title: "", message: "" });
            const [draggedShortcut, setDraggedShortcut] = useState(null);
            const [activeTab, setActiveTab] = useState('keymap');
            const [jsonInput, setJsonInput] = useState('');
            const [currentLayer, setCurrentLayer] = useState(0); // New state for active layer in UI
            // New state for click-to-assign functionality
            const [selectedKeymapCell, setSelectedKeymapCell] = useState(null); // {index, layer} or null (index is the flat index)
            // New state for Web Serial API support
            const [webSerialSupported, setWebSerialSupported] = useState(false);

            const [macros, setMacros] = useState([
                { id: 1, name: "Macro 1", sequence: "Hello World!" }, // Renamed for consistency with Pico parsing
                { id: 2, name: "Macro 2", sequence: "control+alt+t" }, // Example macro
            ]);
            const [nextMacroId, setNextMacroId] = useState(3);

            // Removed potentiometerConfig state

            // Load profile on component mount and check Web Serial API support
            useEffect(() => {
                loadProfile();
                setWebSerialSupported('serial' in navigator);
            }, []);

            // Handlers for drag and drop
            const handleDrop = (e, flatIndex) => { // Now takes flatIndex directly
                e.preventDefault();
                const data = e.dataTransfer.getData("text/plain");
                let droppedItem;

                try {
                    droppedItem = JSON.parse(data);
                } catch (error) {
                    console.error("Failed to parse dropped data:", error);
                    addLog("Failed to parse dropped data: " + error.message, "error");
                    setDraggedShortcut(null);
                    return;
                }

                const newKeymap = JSON.parse(JSON.stringify(keymap));

                if (droppedItem.isKeymapCell) {
                    const sourceFlatIndex = droppedItem.sourceFlatIndex;
                    const sourceLayer = droppedItem.sourceLayer;

                    if (sourceLayer === currentLayer) {
                        // Swap logic for same layer
                        const tempKey = newKeymap[currentLayer].keys[flatIndex];
                        const tempLabel = newKeymap[currentLayer].labels[flatIndex];

                        newKeymap[currentLayer].keys[flatIndex] = newKeymap[currentLayer].keys[sourceFlatIndex];
                        newKeymap[currentLayer].labels[flatIndex] = newKeymap[currentLayer].labels[sourceFlatIndex];

                        newKeymap[currentLayer].keys[sourceFlatIndex] = tempKey;
                        newKeymap[currentLayer].labels[sourceFlatIndex] = tempLabel;
                    } else {
                        // Copy from another layer
                        newKeymap[currentLayer].keys[flatIndex] = droppedItem.combo;
                        newKeymap[currentLayer].labels[flatIndex] = droppedItem.description;
                    }
                } else {
                    // Assign new shortcut
                    newKeymap[currentLayer].keys[flatIndex] = droppedItem.combo;
                    newKeymap[currentLayer].labels[flatIndex] = droppedItem.description;
                }

                setKeymap(newKeymap);
                setDraggedShortcut(null);
                setSelectedKeymapCell(null); // Clear any active cell selection after drag-drop
                addLog(`Key assigned to Layer ${currentLayer}, Index ${flatIndex}.`, "info");
            };


            const handleKeymapDragStart = (e, cellContent, flatIndex) => { // Now takes flatIndex directly
                // Pass the combo and description for dragging
                const dragData = JSON.stringify({ isKeymapCell: true, cell: cellContent, sourceFlatIndex: flatIndex, sourceLayer: currentLayer });
                e.dataTransfer.setData("text/plain", dragData);
                setSelectedKeymapCell(null); // Clear any active cell selection on drag start
            };

            const handleShortcutDragStart = (e, shortcut) => {
                e.dataTransfer.setData("text/plain", JSON.stringify(shortcut));
                setDraggedShortcut(shortcut);
                setSelectedKeymapCell(null); // Clear any active cell selection on drag start
            };

            const handleDragEnd = () => {
                setDraggedShortcut(null);
            };

            const clearKeymapCell = (flatIndex) => { // Now takes flatIndex directly
                const numKeysInCurrentGrid = gridSize * gridSize;
                const updatedKeymap = keymap.map((layer, lIdx) => {
                    if (lIdx === currentLayer) {
                        const newKeys = [...layer.keys];
                        const newLabels = [...layer.labels];
                        if (flatIndex < newKeys.length) { // Ensure index is within bounds
                            newKeys[flatIndex] = null; // Set key to null
                            newLabels[flatIndex] = ''; // Clear label
                        }
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }
                    return layer;
                });
                setKeymap(updatedKeymap);
                setSelectedKeymapCell(null); // Clear selection if the cleared cell was selected
                addLog(`Keymap cell Layer ${currentLayer}, Index ${flatIndex} cleared.`, "info");
            };

            // New handler for clicking a keymap cell
            const handleKeymapCellClick = (flatIndex, layer) => { // Now takes flatIndex directly
                // If the clicked cell is already selected, deselect it
                if (selectedKeymapCell && selectedKeymapCell.index === flatIndex && selectedKeymapCell.layer === layer) {
                    setSelectedKeymapCell(null);
                    addLog(`Deselected keymap cell Layer ${layer}, Index ${flatIndex}.`, "info");
                } else {
                    // Otherwise, select this cell
                    setSelectedKeymapCell({ index: flatIndex, layer }); // Store index
                    addLog(`Selected keymap cell Layer ${layer}, Index ${flatIndex}.`, "info");
                }
            };

            // New handler for clicking a shortcut in the pool
            const handleShortcutClick = (shortcut) => {
                if (selectedKeymapCell) {
                    const { index, layer } = selectedKeymapCell; // Get index
                    const newKeymap = JSON.parse(JSON.stringify(keymap));
                    if (index < newKeymap[layer].keys.length) { // Ensure index is valid
                        newKeymap[layer].keys[index] = shortcut.combo;
                        newKeymap[layer].labels[index] = shortcut.description; // Store description as label
                    } else {
                        addLog(`Attempted to assign shortcut to out-of-bounds index ${index} on Layer ${layer}.`, "error");
                        setModalContent({
                            title: "Assignment Error",
                            message: `The selected key position (index ${index}) is outside the current keymap grid. This might indicate an issue with your physical layout.`
                        });
                        setShowModal(true);
                        return;
                    }
                    setKeymap(newKeymap);
                    setSelectedKeymapCell(null); // Clear selection after assignment
                    addLog(`Assigned "${shortcut.combo}" to Layer ${layer}, Index ${index}.`, "info");
                } else {
                    // Optionally, you could show a modal or message if no cell is selected
                    setModalContent({
                        title: "No Keymap Cell Selected",
                        message: "Please click a keymap cell first to select it, then click a shortcut to assign it."
                    });
                    setShowModal(true);
                    addLog("Attempted to assign shortcut without selecting a keymap cell.", "warn");
                }
            };

            // New handler to clear all cells on the current layer
            const clearCurrentLayer = () => {
                const numKeysInCurrentGrid = gridSize * gridSize;
                setModalContent({
                    title: "Confirm Clear Layer",
                    message: `Are you sure you want to clear all keys on Layer ${currentLayer}? This action cannot be undone.`,
                    onConfirm: () => {
                        const updatedKeymap = keymap.map((layer, lIdx) =>
                            lIdx === currentLayer
                                ? { ...layer, keys: Array(numKeysInCurrentGrid).fill(null), labels: Array(numKeysInCurrentGrid).fill('') }
                                : layer
                        );
                        setKeymap(updatedKeymap);
                        setSelectedKeymapCell(null); // Clear any active cell selection
                        setShowModal(false);
                        addLog(`All keys on Layer ${currentLayer} cleared.`, "info");
                    },
                    onCancel: () => {
                        setShowModal(false);
                        addLog(`Clear Layer ${currentLayer} cancelled.`, "info");
                    }
                });
                setShowModal(true);
            };


            // Profile Management
            const saveProfile = () => {
                const profileData = {
                    keymap: keymap, // Save the multi-layer keymap
                    physicalLayout: physicalLayout, // Save the current physical layout
                    macros: macros,
                    numLayers: numLayers, // Save the number of layers
                    grid_size: gridSize // Save the current grid size
                };
                localStorage.setItem("trkey_profile", JSON.stringify(profileData));
                setModalContent({
                    title: "Profile Saved",
                    message: "Profile saved to browser storage."
                });
                setShowModal(true);
                addLog("Profile saved to browser storage.", "info");
            };

            const loadProfile = () => {
                const saved = localStorage.getItem("trkey_profile");
                if (saved) {
                    const profileData = JSON.parse(saved);
                    
                    const loadedGridSize = profileData.grid_size || DEFAULT_GRID_SIZE;
                    const clampedGridSize = Math.max(MIN_GRID_SIZE, Math.min(MAX_GRID_SIZE, loadedGridSize));
                    setGridSize(clampedGridSize); // Set the grid size

                    const loadedNumLayers = profileData.numLayers || DEFAULT_LAYERS;
                    const clampedNumLayers = Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, loadedNumLayers));
                    setNumLayers(clampedNumLayers);

                    const numKeysInLoadedGrid = clampedGridSize * clampedGridSize;

                    // Load physical layout first, or default if not found/invalid
                    let loadedPhysicalLayout;
                    if (profileData.physicalLayout && Array.isArray(profileData.physicalLayout)) {
                        loadedPhysicalLayout = profileData.physicalLayout.filter(item => item && typeof item.index === 'number' && item.row < clampedGridSize && item.col < clampedGridSize); // Filter out invalid entries
                        loadedPhysicalLayout.sort((a,b) => a.index - b.index); // Ensure it's sorted
                    } else {
                        loadedPhysicalLayout = createDefaultPhysicalLayout(clampedGridSize);
                    }
                    setPhysicalLayout(loadedPhysicalLayout);

                    // Re-initialize keymap based on loadedNumLayers (or clamped) and clampedGridSize
                    const newKeymap = Array(clampedNumLayers).fill().map((_, i) => {
                        if (profileData.keymap && profileData.keymap[i]) {
                            // Deep copy and ensure keys/labels are correct size and only for active physical keys
                            const currentKeys = profileData.keymap[i].keys || [];
                            const currentLabels = profileData.keymap[i].labels || [];

                            const keys = Array(numKeysInLoadedGrid).fill(null);
                            const labels = Array(numKeysInLoadedGrid).fill('');

                            loadedPhysicalLayout.forEach(layoutItem => {
                                if (layoutItem && layoutItem.index !== null && layoutItem.index < currentKeys.length) {
                                    keys[layoutItem.index] = currentKeys[layoutItem.index];
                                    labels[layoutItem.index] = currentLabels[layoutItem.index];
                                }
                            });

                            return { ...profileData.keymap[i], 
                                keys: keys, 
                                labels: labels 
                            };
                        } else {
                            // Create new empty layer respecting the new grid size and physical layout
                            const newEmptyLayerKeys = Array(numKeysInLoadedGrid).fill(null);
                            const newEmptyLayerLabels = Array(numKeysInLoadedGrid).fill('');
                            return { ...createEmptyLayer(i, clampedGridSize), keys: newEmptyLayerKeys, labels: newEmptyLayerLabels };
                        }
                    });
                    setKeymap(newKeymap);

                    setMacros(profileData.macros || []);

                    // Adjust currentLayer if it's out of bounds after loading
                    setCurrentLayer(prevCurrentLayer => {
                        if (prevCurrentLayer >= clampedNumLayers) {
                            return clampedNumLayers > 0 ? clampedNumLayers - 1 : 0;
                        }
                        return prevCurrentLayer;
                    });

                    setModalContent({
                        title: "Profile Loaded",
                        message: "Profile loaded successfully."
                    });
                    addLog("Profile loaded from browser storage.", "info");
                } else {
                    setModalContent({
                        title: "No Profile Found",
                        message: "No saved profile found. Initializing with default layers and layout."
                    });
                    setGridSize(DEFAULT_GRID_SIZE);
                    setKeymap(Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i, DEFAULT_GRID_SIZE)));
                    setNumLayers(DEFAULT_LAYERS);
                    setPhysicalLayout(createDefaultPhysicalLayout(DEFAULT_GRID_SIZE)); // Also set default physical layout
                    addLog("No saved profile found in browser storage. Initialized with default layers and layout.", "info");
                }
                setShowModal(true);
            };

            // Export and Upload
            const exportKeymap = () => {
                // Transform the internal multi-layer keymap state to the Pico-friendly layers.json format
                const layersForExport = []; // Array of layer objects

                // Use the current numLayers for export
                keymap.slice(0, numLayers).forEach((layerData, lIdx) => {
                    // Ensure layerData has 'name', 'labels', 'keys'
                    const layerName = layerData.name || `Layer ${lIdx}`;
                    
                    // Filter keys and labels to only include those that are part of the physical layout
                    const exportKeys = Array(gridSize * gridSize).fill(""); // Initialize with empty strings
                    const exportLabels = Array(gridSize * gridSize).fill("");

                    physicalLayout.forEach(layoutItem => {
                        if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < layerData.keys.length) {
                             exportKeys[layoutItem.index] = layerData.keys[layoutItem.index] || "NO_OP"; // Default to NO_OP if null
                             exportLabels[layoutItem.index] = layerData.labels[layoutItem.index] || "";
                        }
                    });

                    layersForExport.push({
                        name: layerName,
                        labels: exportLabels,
                        keys: exportKeys
                    });
                });

                const fullExportData = {
                    grid_size: gridSize, // Include the current grid size
                    physical_layout: physicalLayout, // Include the physical layout
                    layers: layersForExport // Include the layers array
                };

                // Macros are typically added to the first layer in Pico's layers.json
                if (macros.length > 0) {
                    if (fullExportData.layers.length > 0) {
                         // Ensure macros are stored as {name: "Macro X", sequence: "..."}
                         fullExportData.layers[0].macros = macros.map(m => ({ name: m.name, sequence: m.sequence }));
                    }
                }

                const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "layers.json"; // Changed filename to layers.json
                a.click();
                setModalContent({
                    title: "Export Successful",
                    message: "Configuration exported as layers.json. Drag this file onto your CIRCUITPY drive."
                });
                setShowModal(true);
                addLog("Configuration exported as layers.json.", "info");
            };

            const uploadToDevice = async () => {
                try {
                    if (!webSerialSupported) {
                        setModalContent({
                            title: "Web Serial API Not Supported",
                            message: "Your browser does not support the Web Serial API. Please use a Chromium-based browser (e.g., Chrome, Edge) to upload to device."
                        });
                        setShowModal(true);
                        addLog("Web Serial API not supported.", "error");
                        return;
                    }

                    if (!isConnected) {
                        setModalContent({
                            title: "Not Connected",
                            message: "Please connect to your Pico device first."
                        });
                        setShowModal(true);
                        addLog("Not connected to Pico for upload.", "warn");
                        return;
                    }

                    // Transform the internal multi-layer keymap state to the Pico-friendly layers.json format
                    const layersForUpload = [];
                    // Use the current numLayers for upload
                    keymap.slice(0, numLayers).forEach((layerData, lIdx) => {
                        const layerName = layerData.name || `Layer ${lIdx}`;
                        
                        // Filter keys and labels to only include those that are part of the physical layout
                        const uploadKeys = Array(gridSize * gridSize).fill(""); // Initialize with empty strings
                        const uploadLabels = Array(gridSize * gridSize).fill("");

                        physicalLayout.forEach(layoutItem => {
                            if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < layerData.keys.length) {
                                uploadKeys[layoutItem.index] = layerData.keys[layoutItem.index] || "NO_OP"; // Default to NO_OP if null
                                uploadLabels[layoutItem.index] = layerData.labels[layoutItem.index] || "";
                            }
                        });

                        layersForUpload.push({
                            name: layerName,
                            labels: uploadLabels,
                            keys: uploadKeys
                        });
                    });

                    const fullUploadData = {
                        grid_size: gridSize, // Include the current grid size
                        physical_layout: physicalLayout, // Include the physical layout
                        layers: layersForUpload, // Include the layers array
                    };

                    // Add macros to the first layer for upload
                    if (macros.length > 0 && fullUploadData.layers.length > 0) {
                        fullUploadData.layers[0].macros = macros.map(m => ({ name: m.name, sequence: m.sequence }));
                    }

                    const json = JSON.stringify(fullUploadData);
                    const blob = new Blob([json], { type: "application/json" });
                    
                    // Create a File object from the Blob
                    const fileToUpload = new File([blob], "layers.json", { type: "application/json" });

                    setModalContent({
                        title: "Uploading...",
                        message: "Uploading layers.json to Pico. Please wait."
                    });
                    setShowModal(true);
                    addLog("Starting layers.json upload to Pico...", "info");

                    await putFile(fileToUpload); // Pass the File object
                    
                    setModalContent({
                        title: "Upload Successful",
                        message: "Configuration uploaded successfully!"
                    });
                    addLog("Configuration uploaded successfully!", "success");
                } catch (err) {
                    setModalContent({
                        title: "Upload Failed",
                        message: "Failed to upload: " + err.message
                    });
                    addLog(`Upload failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleConnectPico = async () => {
                await connectPico();
            };

            const handleGetFile = async (filename) => {
                try {
                    if (!isConnected) {
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device first." });
                        setShowModal(true);
                        addLog("Not connected to Pico for file check.", "warn");
                        return;
                    }
                    setModalContent({ title: "Checking...", message: `Checking ${filename} on Pico. Please wait.` });
                    setShowModal(true);
                    addLog(`Starting check of ${filename} on Pico...`, "info");
                    const blob = await getFile(filename); // getFile now just returns blob
                    const text = await blob.text();
                    
                    // Attempt to pretty-print if it's JSON
                    try {
                        const parsed = JSON.parse(text);
                        setJsonInput(JSON.stringify(parsed, null, 2));
                    } catch (parseError) {
                        setJsonInput(text); // If not JSON, just set the raw text
                    }
                    
                    setActiveTab('settings'); // Switch to settings tab to show the content
                    setModalContent({ title: "Check Successful", message: `${filename} content loaded into settings tab.` });
                    addLog(`${filename} content loaded into settings tab.`, "success");
                } catch (err) { // Corrected syntax: removed '=>'
                    setModalContent({ title: "Check Failed", message: `Failed to check ${filename}: ${err.message}` });
                    addLog(`Check of ${filename} failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleDeleteFile = async (filename) => {
                try {
                    if (!isConnected) {
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device first." });
                        setShowModal(true);
                        addLog("Not connected to Pico for file deletion.", "warn");
                        return;
                    }
                    setModalContent({
                        title: "Confirm Delete",
                        message: `Are you sure you want to delete ${filename} from Pico?`,
                        onConfirm: async () => {
                            setShowModal(false); // Close confirmation modal
                            setModalContent({ title: "Deleting...", message: `Deleting ${filename} from Pico. Please wait.` });
                            setShowModal(true);
                            addLog(`Confirming deletion of ${filename}...`, "info");
                            await deleteFile(filename); // deleteFile now handles its own response logging
                            setModalContent({ title: "Delete Successful", message: `${filename} deleted.` });
                            addLog(`${filename} deleted successfully.`, "success");
                            setShowModal(true);
                        },
                        onCancel: () => {
                            setShowModal(false);
                            addLog(`Deletion of ${filename} cancelled.`, "info");
                        }
                    });
                    setShowModal(true);
                } catch (err) {
                    setModalContent({ title: "Delete Failed", message: `Failed to delete ${filename}: ${err.message}` });
                    addLog(`Deletion of ${filename} failed: ${err.message}`, "error");
                    setShowModal(true);
                }
            };


            // Refactored JSON Load function (from manual input or auto-load)
            const loadConfigFromJson = (jsonString, source = "manual") => {
                try {
                    const parsedJson = JSON.parse(jsonString);
                    addLog(`Loading configuration from ${source} source.`, "info");

                    // Expecting a root object with 'physical_layout' and 'layers' keys
                    if (typeof parsedJson === 'object' && parsedJson !== null && Array.isArray(parsedJson.layers)) {
                        // Load grid size first
                        const loadedGridSize = parsedJson.grid_size || DEFAULT_GRID_SIZE;
                        const clampedGridSize = Math.max(MIN_GRID_SIZE, Math.min(MAX_GRID_SIZE, loadedGridSize));
                        setGridSize(clampedGridSize);
                        const numKeysInLoadedGrid = clampedGridSize * clampedGridSize;

                        // Load layers
                        const loadedLayers = parsedJson.layers;
                        const loadedNumLayers = Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, loadedLayers.length));
                        setNumLayers(loadedNumLayers); // Update the numLayers state

                        const newKeymap = Array(loadedNumLayers).fill().map((_, layerIdx) => {
                            if (loadedLayers[layerIdx]) {
                                // Ensure keys/labels are correct size and only for active physical keys
                                const layerKeys = Array.isArray(loadedLayers[layerIdx].keys) ? loadedLayers[layerIdx].keys : [];
                                const layerLabels = Array.isArray(loadedLayers[layerIdx].labels) ? loadedLayers[layerIdx].labels : [];

                                const keys = Array(numKeysInLoadedGrid).fill(null);
                                const labels = Array(numKeysInLoadedGrid).fill('');

                                // Iterate through the loaded physical layout to fill the keymap
                                const currentPhysicalLayout = Array.isArray(parsedJson.physical_layout) ? parsedJson.physical_layout : [];
                                currentPhysicalLayout.forEach(layoutItem => {
                                    if (layoutItem && typeof layoutItem.index === 'number' && layoutItem.index < numKeysInLoadedGrid) {
                                        keys[layoutItem.index] = layerKeys[layoutItem.index] || null;
                                        labels[layoutItem.index] = layerLabels[layoutItem.index] || '';
                                    }
                                });

                                return {
                                    name: loadedLayers[layerIdx].name || `Layer ${layerIdx}`,
                                    labels: labels,
                                    keys: keys,
                                    macros: loadedLayers[layerIdx].macros || []
                                };
                            } else {
                                return createEmptyLayer(layerIdx, clampedGridSize);
                            }
                        });
                        setKeymap(newKeymap);

                        // Load physical_layout
                        if (Array.isArray(parsedJson.physical_layout)) {
                            // Validate physical_layout: ensure it contains objects with index, row, col, or null
                            const validatedPhysicalLayout = parsedJson.physical_layout.map(item => {
                                if (item === null || (typeof item === 'object' && item !== null && 'index' in item && 'row' in item && 'col' in item)) {
                                    return item;
                                }
                                return null; // Invalid items become null
                            }).filter(item => item !== null && item.row < clampedGridSize && item.col < clampedGridSize); // Filter out items outside new grid bounds
                            validatedPhysicalLayout.sort((a,b) => a.index - b.index); // Sort by index
                            setPhysicalLayout(validatedPhysicalLayout);
                            addLog(`Physical layout loaded from JSON. Detected ${validatedPhysicalLayout.length} active key positions.`, "info");
                        } else {
                            const defaultLayout = createDefaultPhysicalLayout(clampedGridSize);
                            setPhysicalLayout(defaultLayout); // Reset to default if not found or invalid
                            addLog("No valid 'physical_layout' found in JSON, defaulting to new grid size layout.", "warn");
                        }

                        let loadedMacros = [];
                        let maxMacroId = 0;

                        // Consolidate macros from all loaded layers (though Pico expects them on layer 0)
                        parsedJson.layers.forEach(layerData => { // Iterate through parsedJson.layers
                            if (layerData.macros && Array.isArray(layerData.macros)) {
                                const newMacrosForLayer = layerData.macros.map((m) => {
                                    // Assign a new, unique ID for internal React state if needed, but keep original if existing
                                    const id = m.id || nextMacroId + loadedMacros.length;
                                    maxMacroId = Math.max(maxMacroId, id);
                                    return { id: id, name: m.name, sequence: m.sequence };
                                });
                                loadedMacros = [...loadedMacros, ...newMacrosForLayer];
                            }
                        });
                        
                        setMacros(loadedMacros);
                        setNextMacroId(maxMacroId + 1); // Update nextMacroId based on loaded macros

                        setCurrentLayer(prevCurrentLayer => {
                            if (prevCurrentLayer >= loadedNumLayers) {
                                return loadedNumLayers > 0 ? loadedNumLayers - 1 : 0;
                            }
                            return prevCurrentLayer;
                        });

                        setJsonInput(JSON.stringify(parsedJson, null, 2)); // Update the textarea with the loaded JSON for consistency

                        addLog(`Configuration loaded from ${source} successfully.`, "success");
                    } else {
                        throw new Error("The pasted JSON does not contain a valid configuration. Expected a root object with 'physical_layout' (optional) and a 'layers' array.");
                    }
                } catch (error) {
                    addLog(`Failed to load configuration from ${source}: ${error.message}`, "error");
                    if (source === "manual") { // Only show modal for manual load errors
                        setModalContent({
                            title: `Configuration Load Error (${source})`,
                            message: `Failed to load configuration: ${error.message}. Please check the JSON format.`
                        });
                        setShowModal(true);
                    }
                    // For auto-load, we already set a modal message in connectPico
                }
            };


            // Macro functions
            const addMacro = () => {
                const name = prompt("Enter macro name (e.g., Macro 1):");
                if (!name) {
                    addLog("Macro creation cancelled (no name provided).", "info");
                    return;
                }
                const sequence = prompt("Enter macro sequence (e.g., 'Hello World!'):");
                if (sequence) {
                    setMacros(prev => [...prev, { id: nextMacroId, name, sequence }]);
                    setNextMacroId(prev => prev + 1);
                    addLog(`Macro "${name}" added.`, "info");
                } else {
                    addLog("Macro creation cancelled (no sequence provided).", "info");
                }
            };

            const editMacro = (id) => {
                const macroToEdit = macros.find(m => m.id === id);
                if (!macroToEdit) {
                    addLog(`Attempted to edit non-existent macro with ID: ${id}.`, "warn");
                    return;
                }

                const newName = prompt(`Edit name for "${macroToEdit.name}":`, macroToEdit.name);
                if (newName === null) {
                    addLog(`Edit for macro "${macroToEdit.name}" cancelled (name).`, "info");
                    return;
                }

                const newSequence = prompt(`Edit sequence for "${macroToEdit.name}":`, macroToEdit.sequence);
                if (newSequence === null) {
                    addLog(`Edit for macro "${macroToEdit.name}" cancelled (sequence).`, "info");
                    return;
                }

                setMacros(prev => prev.map(m =>
                    m.id === id ? { ...m, name: newName, sequence: newSequence } : m
                ));
                addLog(`Macro "${macroToEdit.name}" (ID: ${id}) updated.`, "info");
            };

            const deleteMacro = (id) => {
                setModalContent({
                    title: "Confirm Delete",
                    message: "Are you sure you want to delete this macro?",
                    onConfirm: () => {
                        setMacros(prev => prev.filter(m => m.id !== id));
                        setShowModal(false);
                        addLog(`Macro with ID: ${id} deleted.`, "info");
                    },
                    onCancel: () => {
                        setShowModal(false);
                        addLog(`Deletion of macro with ID: ${id} cancelled.`, "info");
                    }
                });
                setShowModal(true);
            };

            return (
                <div className="min-h-screen bg-zinc-800 text-white flex font-inter">
                    {/* Sidebar */}
                    <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />

                    {/* Main Content Area */}
                    <div className="flex-1 flex flex-col p-4 overflow-auto"> {/* Adjusted padding for overall content */}
                         {/* Web Serial Status Indicator */}
                        <div className="flex justify-end mb-4">
                            <span className={`text-sm px-3 py-1 rounded-full ${webSerialSupported ? 'bg-green-600' : 'bg-red-600'} text-white`}>
                                Web Serial: {webSerialSupported ? 'Supported' : 'Not Supported'}
                            </span>
                        </div>
                        {isLoadingDeviceConfig && (
                            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
                                <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl border-2 border-red-500 flex items-center space-x-4">
                                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-red-500"></div>
                                    <p className="text-lg">Loading configuration from device...</p>
                                </div>
                            </div>
                        )}

                        {activeTab === 'keymap' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for keymap tab content */}
                                <h1 className="text-4xl font-extrabold text-red-400 mb-4">KEYMAP CONFIGURATION</h1>
                                {/* Visual Layer Indicator */}
                                <h2 className="text-2xl font-bold text-zinc-300 mb-8">Currently Viewing: Layer {currentLayer}</h2>
                                <KeymapGrid
                                    keymap={keymap}
                                    handleDrop={handleDrop}
                                    handleKeymapDragStart={handleKeymapDragStart}
                                    handleDragEnd={handleDragEnd}
                                    clearKeymapCell={clearKeymapCell}
                                    currentLayer={currentLayer} // Pass currentLayer
                                    setCurrentLayer={setCurrentLayer} // Pass setter for layer buttons
                                    selectedKeymapCell={selectedKeymapCell} /* New prop */
                                    handleKeymapCellClick={handleKeymapCellClick} /* New prop */
                                    clearCurrentLayer={clearCurrentLayer} /* New prop */
                                    numLayers={numLayers} /* Pass numLayers to KeymapGrid */
                                    physicalLayout={physicalLayout} /* Pass physicalLayout to KeymapGrid */
                                    gridSize={gridSize} /* Pass gridSize to KeymapGrid */
                                />
                                <h2 className="text-3xl font-bold text-red-400 mb-6">SHORTCUTS</h2>
                                <ShortcutPool
                                    shortcutPool={shortcutPool}
                                    draggedShortcut={draggedShortcut}
                                    handleShortcutDragStart={handleShortcutDragStart}
                                    handleDragEnd={handleDragEnd}
                                    selectedKeymapCell={selectedKeymapCell} /* New prop */
                                    handleShortcutClick={handleShortcutClick} /* New prop */
                                />
                            </div>
                        )}

                        {activeTab === 'layout' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700">
                                <LayoutPage /* Renamed component */
                                    gridSize={gridSize}
                                    setGridSize={setGridSize} /* Pass setGridSize */
                                    physicalLayout={physicalLayout}
                                    setPhysicalLayout={setPhysicalLayout}
                                    keymap={keymap} /* Pass keymap */
                                    setKeymap={setKeymap} /* Pass setKeymap to clear keys when mapping changes */
                                    exportKeymap={exportKeymap} /* Pass exportKeymap */
                                    uploadToDevice={uploadToDevice} /* Pass uploadToDevice */
                                    isConnected={isConnected} /* Pass isConnected */
                                    handleConnectPico={handleConnectPico} /* Pass handleConnectPico */
                                    webSerialSupported={webSerialSupported} /* Pass webSerialSupported */
                                />
                            </div>
                        )}

                        {activeTab === 'macros' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for macros tab content */}
                                <MacroManagement
                                    macros={macros}
                                    addMacro={addMacro}
                                    editMacro={editMacro}
                                    deleteMacro={deleteMacro}
                                />
                            </div>
                        )}

                        {activeTab === 'save-load' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for save-load tab content */}
                                <SaveLoad
                                    saveProfile={saveProfile}
                                    loadProfile={loadProfile}
                                    exportKeymap={exportKeymap}
                                    uploadToDevice={uploadToDevice}
                                    isConnected={isConnected} /* New prop */
                                    handleConnectPico={handleConnectPico} /* New prop */
                                    handleGetFile={handleGetFile} /* Modified prop */
                                    handleDeleteFile={handleDeleteFile} /* New prop */
                                    logs={logs} /* New prop */
                                    clearLogs={clearLogs} /* New prop */
                                    showLogDropdown={showLogDropdown} /* New prop */
                                    toggleLogDropdown={toggleLogDropdown} /* New prop */
                                />
                            </div>
                        )}

                        {activeTab === 'settings' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for settings tab content */}
                                <Settings
                                    jsonInput={jsonInput}
                                    setJsonInput={setJsonInput}
                                    loadConfigFromJson={loadConfigFromJson} /* Pass the refactored load function */
                                    numLayers={numLayers} /* Pass numLayers */
                                    setNumLayers={setNumLayers} /* Pass setNumLayers */
                                />
                            </div>
                        )}

                        {activeTab === 'keytester' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for keytester tab content */}\
                                <KeyTester activeTab={activeTab} />
                            </div>
                        )}
                    </div>

                    {/* Modals */}
                    <Modal
                        show={showModal && !modalContent.onConfirm}
                        title={modalContent.title}
                        message={modalContent.message}
                        onClose={() => setShowModal(false)}
                    />
                    <ConfirmationModal
                        show={showModal && modalContent.onConfirm}
                        title={modalContent.title}
                        message={modalContent.message}
                        onConfirm={modalContent.onConfirm}
                        onCancel={modalContent.onCancel}
                    />
                </div>
            );
        }

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
