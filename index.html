<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trkey Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom scrollbar styling for Tailwind's custom-scrollbar class */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #3f3f46; /* zinc-700 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #ef4444; /* red-500 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #dc2626; /* red-600 */
        }
        /* Allow body and root to scroll */
        html, body, #root {
            min-height: 100%; /* Ensure they take at least full height, but can grow */
            margin: 0;
            /* Removed overflow: hidden; as it can hide content when modals are shown */
        }
    </style>
</head>
<body class="font-inter">
    <div id="root"></div>

    <script type="text/babel">
        // All React component code consolidated here

        // Explicitly get React and ReactDOM from the window object
        const React = window.React;
        const ReactDOM = window.ReactDOM;

        // Constants with ALL shortcuts from the PDF, adapted for CircuitPython Keycode names
        const presets = {
            "STANDARD_KEYS": [
                { combo: "A", description: "A" },
                { combo: "B", description: "B" },
                { combo: "C", description: "C" },
                { combo: "D", description: "D" },
                { combo: "E", description: "E" },
                { combo: "F", description: "F" },
                { combo: "G", description: "G" },
                { combo: "H", description: "H" },
                { combo: "I", description: "I" },
                { combo: "J", description: "J" },
                { combo: "K", description: "K" },
                { combo: "L", description: "L" },
                { combo: "M", description: "M" },
                { combo: "N", description: "N" },
                { combo: "O", description: "O" },
                { combo: "P", description: "P" },
                { combo: "Q", description: "Q" },
                { combo: "R", description: "R" },
                { combo: "S", description: "S" },
                { combo: "T", description: "T" },
                { combo: "U", description: "U" },
                { combo: "V", description: "V" },
                { combo: "W", description: "W" },
                { combo: "X", description: "X" },
                { combo: "Y", description: "Y" },
                { combo: "Z", description: "Z" },
                { combo: "ONE", description: "1" },
                { combo: "TWO", description: "2" },
                { combo: "THREE", description: "3" },
                { combo: "FOUR", description: "4" },
                { combo: "FIVE", description: "5" },
                { combo: "SIX", description: "6" },
                { combo: "SEVEN", description: "7" },
                { combo: "EIGHT", description: "8" },
                { combo: "NINE", description: "9" },
                { combo: "ZERO", description: "0" },
                { combo: "ENTER", description: "Enter" },
                { combo: "ESCAPE", description: "Esc" },
                { combo: "TAB", description: "Tab" },
                { combo: "SPACEBAR", description: "Space" },
                { combo: "BACKSPACE", description: "Bksp" },
                { combo: "DELETE", description: "Del" },
                { combo: "CAPS_LOCK", description: "Caps" },
                { combo: "F1", description: "F1" },
                { combo: "F2", description: "F2" },
                { combo: "F3", description: "F3" },
                { combo: "F4", description: "F4" },
                { combo: "F5", description: "F5" },
                { combo: "F6", description: "F6" },
                { combo: "F7", description: "F7" },
                { combo: "F8", description: "F8" },
                { combo: "F9", description: "F9" },
                { combo: "F10", description: "F10" },
                { combo: "F11", description: "F11" },
                { combo: "F12", description: "F12" },
                { combo: "PRINT_SCREEN", description: "PrtSc" },
                { combo: "SCROLL_LOCK", description: "ScrLk" },
                { combo: "PAUSE", description: "Pause" },
                { combo: "INSERT", description: "Ins" },
                { combo: "HOME", description: "Home" },
                { combo: "PAGE_UP", description: "PgUp" },
                { combo: "PAGE_DOWN", description: "PgDn" },
                { combo: "END", description: "End" },
                { combo: "RIGHT_ARROW", description: "R Arrow" },
                { combo: "LEFT_ARROW", description: "L Arrow" },
                { combo: "DOWN_ARROW", description: "Dn Arrow" },
                { combo: "UP_ARROW", description: "Up Arrow" },
                { combo: "KEYPAD_NUMLOCK", description: "NumLk" },
                { combo: "KEYPAD_SLASH", description: "Kp /" },
                { combo: "KEYPAD_ASTERISK", description: "Kp *" },
                { combo: "KEYPAD_MINUS", description: "Kp -" },
                { combo: "KEYPAD_PLUS", description: "Kp +" },
                { combo: "KEYPAD_ENTER", description: "Kp Ent" },
                { combo: "KEYPAD_ONE", description: "Kp 1" },
                { combo: "KEYPAD_TWO", description: "Kp 2" },
                { combo: "KEYPAD_THREE", description: "Kp 3" },
                { combo: "KEYPAD_FOUR", description: "Kp 4" },
                { combo: "KEYPAD_FIVE", description: "Kp 5" },
                { combo: "KEYPAD_SIX", description: "Kp 6" },
                { combo: "KEYPAD_SEVEN", description: "Kp 7" },
                { combo: "KEYPAD_EIGHT", description: "Kp 8" },
                { combo: "KEYPAD_NINE", description: "Kp 9" },
                { combo: "KEYPAD_ZERO", description: "Kp 0" },
                { combo: "KEYPAD_PERIOD", description: "Kp ." },
                { combo: "NON_US_SLASH", description: "Non-US /" },
                { combo: "APPLICATION", description: "App Key" },
                { combo: "COMMA", description: "Comma" },
                { combo: "PERIOD", description: "Period" },
                { combo: "GRAVE_ACCENT", description: "Grave" },
                { combo: "MINUS", description: "Minus" },
                { combo: "EQUAL", description: "Equal" },
                { combo: "LEFT_BRACKET", description: "L Brkt" },
                { combo: "RIGHT_BRACKET", description: "R Brkt" },
                { combo: "BACKSLASH", description: "Bcksl" },
                { combo: "SEMICOLON", description: "Semicln" },
                { combo: "QUOTE", description: "Quote" },
                { combo: "SLASH", description: "Slash" },
            ],
            "MODIFIER_KEYS": [
                { combo: "LEFT_CONTROL", description: "L Ctrl" },
                { combo: "LEFT_SHIFT", description: "L Shift" },
                { combo: "LEFT_ALT", description: "L Alt" },
                { combo: "LEFT_GUI", description: "L GUI" },
                { combo: "RIGHT_CONTROL", description: "R Ctrl" },
                { combo: "RIGHT_SHIFT", description: "R Shift" },
                { combo: "RIGHT_ALT", description: "R Alt" },
                { combo: "RIGHT_GUI", description: "R GUI" },
            ],
            "COMBINATION_SHORTCUTS": [
                { combo: "CONTROL_C", description: "Copy" },
                { combo: "CONTROL_V", description: "Paste" },
                { combo: "CONTROL_X", description: "Cut" },
                { combo: "CONTROL_Z", description: "Undo" },
                { combo: "CONTROL_Y", description: "Redo" },
                { combo: "CONTROL_S", description: "Save" },
                { combo: "ALT_TAB", description: "App Switch" },
                { combo: "GUI_D", description: "Desktop" },
                { combo: "CONTROL_SHIFT_ESCAPE", description: "TaskMgr" },
                { combo: "CONTROL_A", description: "Sel All" },
                { combo: "CONTROL_F", description: "Find" },
                { combo: "CONTROL_P", description: "Print" },
                { combo: "CONTROL_L", description: "Align L" },
                { combo: "CONTROL_R", description: "Align R" },
                { combo: "CONTROL_E", description: "Align C" },
                { combo: "CONTROL_D", description: "Dupe" },
                { combo: "CONTROL_G", description: "Group" },
                { combo: "CONTROL_U", description: "Ungrp" },
                { combo: "CONTROL_K", description: "Link" },
                { combo: "CONTROL_H", description: "Replace" },
                { combo: "CONTROL_B", description: "Bold" },
                { combo: "CONTROL_I", description: "Italic" },
                { combo: "CONTROL_U", description: "Undrl" },
                { combo: "ALT_ENTER", description: "Fullscreen" },
                { combo: "SHIFT_ARROW", description: "Nudge" },
                { combo: "SHIFT_SPACEBAR", description: "Cycle Units" },
                { combo: "CONTROL_SPACEBAR", description: "Suggest" },
                { combo: "CONTROL_FORWARD_SLASH", description: "Comment" },
                { combo: "ALT_UP_ARROW", description: "Line Up" },
                { combo: "ALT_DOWN_ARROW", description: "Line Dn" },
                { combo: "SHIFT_ALT_DOWN_ARROW", description: "Copy Line" },
                { combo: "CONTROL_SHIFT_K", description: "Del Line" },
                { combo: "CONTROL_ENTER", description: "Ins Line B" },
                { combo: "CONTROL_SHIFT_ENTER", description: "Ins Line A" },
                { combo: "CONTROL_SHIFT_RIGHT_BRACKET", description: "Jmp Brkt" },
                { combo: "CONTROL_TAB", description: "Next Edit" },
                { combo: "CONTROL_SHIFT_TAB", description: "Prev Edit" },
                { combo: "CONTROL_W", description: "Close Tab" },
                { combo: "CONTROL_ALT_T", description: "Terminal" },
                { combo: "CONTROL_SHIFT_P", description: "Cmd Pal" },
                { combo: "CONTROL_GRAVE_ACCENT", description: "Term Tog" },
                { combo: "CONTROL_B", description: "Side Tog" },
                { combo: "CONTROL_J", description: "Panel Tog" },
                { combo: "CONTROL_SHIFT_E", description: "Explorer" },
                { combo: "CONTROL_SHIFT_F", description: "File Srch" },
                { combo: "CONTROL_SHIFT_G", description: "Git" },
                { combo: "CONTROL_SHIFT_D", description: "Debug" },
                { combo: "CONTROL_SHIFT_X", description: "Extens" },
                { combo: "CONTROL_SHIFT_S", description: "Save As" },
                { combo: "CONTROL_N", description: "New File" },
                { combo: "CONTROL_O", description: "Open File" },
                { combo: "CONTROL_Q", description: "Quit App" },
                { combo: "CONTROL_ALT_DELETE", description: "Force Quit" },
                { combo: "CONTROL_SHIFT", description: "Walk" },
                { combo: "CONTROL_F1", description: "Switch Class" },
                { combo: "ALT_V", description: "View Chg" },
                { combo: "ALT_M", description: "Minimap" },
                { combo: "CONTROL_R", description: "Reload" },
                { combo: "ALT_F4", description: "Close Win" },
                { combo: "CONTROL_Y", description: "Chat" },
                { combo: "CONTROL_G", description: "Gun View" },
                { combo: "CONTROL_T", description: "Anchor" },
                { combo: "CONTROL_SHIFT_M", description: "Model" },
                { combo: "CONTROL_ALT_T", description: "Terrain" },
                { combo: "CONTROL_SHIFT_R", description: "Run" },
                { combo: "CONTROL_SHIFT_T", description: "Test" },
                { combo: "CONTROL_SHIFT_F", description: "Search All" },
                { combo: "CONTROL_SHIFT_D", description: "Download" },
                { combo: "CONTROL_SHIFT_C", description: "Output" },
                { combo: "CONTROL_SHIFT_H", description: "View Exp" },
                { combo: "CONTROL_SHIFT_X", description: "Props" },
                { combo: "CONTROL_SHIFT_E", description: "Toolbox" },
                { combo: "ALT_LEFT_BRACKET", description: "Lyr Back" },
                { combo: "ALT_RIGHT_BRACKET", description: "Lyr Fwd" },
                { combo: "ALT_SHIFT_E", description: "Export" },
            ],
            "MEDIA_CONTROLS": [
                { combo: "VOLUME_INCREMENT", description: "Vol Up" },
                { combo: "VOLUME_DECREMENT", description: "Vol Down" },
                { combo: "MUTE", description: "Mute" },
                { combo: "PLAY_PAUSE", description: "Play/Pse" },
                { combo: "SCAN_PREVIOUS_TRACK", description: "Prev Trk" },
                { combo: "SCAN_NEXT_TRACK", description: "Next Trk" },
            ],
            "MOUSE_ACTIONS": [
                { combo: "MOUSE_BUTTON_1", description: "L Click" },
                { combo: "MOUSE_BUTTON_2", description: "R Click" },
                { combo: "MOUSE_BUTTON_3", description: "M Click" },
                { combo: "MOUSE_WHEEL_UP", description: "Scroll Up" },
                { combo: "MOUSE_WHEEL_DOWN", description: "Scroll Dn" },
                { combo: "ALT_DRAG", description: "Alt Drag" },
                { combo: "SHIFT_DRAG", description: "Shft Drag" },
                { combo: "CONTROL_CLICK", description: "Ctrl Click" },
                { combo: "CONTROL_MIDDLE_CLICK", description: "Ctrl M Click" },
                { combo: "SHIFT_LEFT_CLICK", description: "Shft L Click" },
                { combo: "SHIFT_RIGHT_CLICK", description: "Shft R Click" },
                { combo: "DOUBLE_CLICK", description: "Dbl Click" },
            ],
            "MACROS": [
                { combo: "MACRO_1", description: "Macro 1" },
                { combo: "MACRO_2", description: "Macro 2" },
                { combo: "MACRO_3", description: "Macro 3" },
            ],
            "LAYER_CONTROLS": [
                { combo: "TG_1", description: "Toggle L1" },
                { combo: "MO_1", description: "Moment L1" },
                { combo: "TO_0", description: "To L0" },
            ],
            "SYSTEM_CONTROLS": [
                { combo: "POWER", description: "Power" },
                { combo: "SLEEP", description: "Sleep" },
                { combo: "WAKE", description: "Wake" },
            ],
            "MINECRAFT_SPECIFIC": [
                { combo: "W_KEY", description: "Fwd" },
                { combo: "A_KEY", description: "Left" },
                { combo: "S_KEY", description: "Bck" },
                { combo: "D_KEY", description: "Right" },
                { combo: "DOUBLE_SPACE", description: "Fly Tog" },
                { combo: "NUMBER_HOVER", description: "Hotbar" },
                { combo: "F3_D", description: "Clr Chat" },
                { combo: "F3_N", description: "GM Swch" },
                { combo: "F3_C", description: "Crash" },
                { combo: "F3_A", description: "Reload" },
            ],
            "KICAD_SPECIFIC": [
                { combo: "CONTROL_SCROLL", description: "Zoom" },
                { combo: "ALT_ONE", description: "Lyr Vw 1" },
                { combo: "ALT_TWO", description: "Lyr Vw 2" },
                { combo: "ALT_THREE", description: "Lyr Vw 3" },
                { combo: "ALT_FOUR", description: "Lyr Vw 4" },
                { combo: "ALT_FIVE", description: "Lyr w 5" },
            ],
            "FUSION360_SPECIFIC": [
                { combo: "SHIFT_SCROLL", description: "Pan" },
            ],
        };

        const MIN_LAYERS = 1;
        const MAX_LAYERS = 10;
        const DEFAULT_LAYERS = 2; // Default number of layers for initial load if no profile exists

        // Helper function to create an empty layer object
        const createEmptyLayer = (index) => ({
            name: `Layer ${index}`,
            labels: Array(9).fill(''), // Always 9 elements for the 3x3 grid internally
            keys: Array(9).fill(null), // Always 9 elements for the 3x3 grid internally
            macros: [] // Macros are technically global to the app but stored on Layer 0 in JSON
        });

        // Helper function to create a default 3x3 physical layout
        const createDefaultPhysicalLayout = () => {
            const layout = [];
            for (let i = 0; i < 9; i++) {
                layout.push({ index: i, row: Math.floor(i / 3), col: i % 3 });
            }
            return layout;
        };


        // Modal component (formerly from src/components/Modal.js)
        const Modal = ({ show, title, message, onClose }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{title}</h3>
                        {message && <p className="mb-4">{message}</p>}
                        <div className="flex justify-end">
                            <button
                                onClick={onClose}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                OK
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Confirmation Modal (formerly from src/components/ConfirmationModal.js)
        const ConfirmationModal = ({ show, title, message, onConfirm, onCancel }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-zinc-800 text-white p-6 rounded-lg shadow-xl max-w-sm w-full border-2 border-red-500">
                        <h3 className="text-xl font-bold mb-4 text-red-400">{title}</h3>
                        {message && <p className="mb-4">{message}</p>}
                        <div className="flex justify-end space-x-4">
                            <button
                                onClick={onCancel}
                                className="bg-zinc-600 hover:bg-zinc-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={onConfirm}
                                className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200"
                            >
                                Confirm
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Sidebar component (formerly from src/components/Sidebar.js)
        const Sidebar = ({ activeTab, setActiveTab }) => {
            const { useState, useEffect } = React; // Ensure React hooks are imported within component scope
            return (
                <div className="w-64 bg-zinc-900 p-6 flex flex-col border-r border-zinc-700 shadow-xl">
                    <div className="text-2xl font-bold text-red-500 mb-8">Trkey</div>
                    <nav className="flex-grow">
                        <ul className="space-y-4">
                            <li>
                                <a href="#" onClick={() => setActiveTab('keymap')} className={`flex items-center ${activeTab === 'keymap' ? 'text-red-300' : 'text-zinc-400'} hover:text-red-500 font-semibold text-lg transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path></svg>
                                    KEYMAP
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('macros')} className={`flex items-center ${activeTab === 'macros' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M12 6.293V4a1 1 0 00-1-1H5a1 1 0 00-1 1v10a1 1 0 001 1h6a1 1 0 001-1v-2.293l1.707 1.707a1 1 0 001.414-1.414l-4-4a1 1 0 00-1.414 0l-4 4a1 1 0 001.414 1.414L10 10.414V12a1 1 0 001 1h2a1 1 0 001-1V8.293l1.707 1.707a1 1 0 001.414-1.414l-4-4z"></path></svg>
                                    MACROS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('controls')} className={`flex items-center ${activeTab === 'controls' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 100-2 1 1 0 000 2zm6-1a1 1 0 100-2 1 1 0 000 2zm-3 8a1 1 0 100-2 1 1 0 000 2z"></path></svg>
                                    CONTROLS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('save-load')} className={`flex items-center ${activeTab === 'save-load' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z"></path></svg>
                                    SAVE + LOAD
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('settings')} className={`flex items-center ${activeTab === 'settings' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 00-1 1v1a1 1 0 002 0V3a1 1 0 00-1-1zm4 4a1 1 0 011 1v1a1 1 0 01-2 0V7a1 1 0 011-1zM6 6a1 1 0 00-1 1v1a1 1 0 002 0V7a1 1 0 00-1-1zm0 8a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm8 0a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm-4 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zM2 10a1 1 0 001 1h1a1 1 0 000-2H3a1 1 0 00-1 1zm14 0a1 1 0 001 1h1a1 1 0 000-2h-1a1 1 0 00-1 1zM7 10a3 3 0 116 0 3 3 0 01-6 0z"></path></svg>
                                    SETTINGS
                                </a>
                            </li>
                            <li>
                                <a href="#" onClick={() => setActiveTab('keytester')} className={`flex items-center ${activeTab === 'keytester' ? 'text-red-300' : 'text-zinc-400'} hover:text-white transition-colors duration-200`}>
                                    <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 002 0V3zM14 8a1 1 0 011 1v1a1 1 0 11-2 0V9a1 1 0 011-1zM6 8a1 1 0 00-1 1v1a1 1 0 002 0V9a1 1 0 00-1-1zm0 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm8 0a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zm-4 4a1 1 0 00-1 1v1a1 1 0 002 0v-1a1 1 0 00-1-1zM2 10a1 1 0 001 1h1a1 1 0 000-2H3a1 1 0 00-1 1zm14 0a1 1 0 001 1h1a1 1 0 000-2h-1a1 1 0 00-1 1zM7 10a3 3 0 116 0 3 3 0 01-6 0z"></path></svg>
                                    KEY TESTER
                                </a>
                            </li>
                        </ul>
                    </nav>
                </div>
            );
        };

        // KeymapGrid component (formerly from src/components/KeymapGrid.js)
        const KeymapGrid = ({ keymap, handleDrop, handleKeymapDragStart, handleDragEnd, clearKeymapCell, currentLayer, setCurrentLayer, selectedKeymapCell, handleKeymapCellClick, clearCurrentLayer, numLayers, physicalLayout }) => {
            const { useState, useEffect } = React;
            // DEBUG: Log the physicalLayout prop received by KeymapGrid
            useEffect(() => {
                console.log("KeymapGrid received physicalLayout:", physicalLayout);
            }, [physicalLayout]);

            // The keymap prop is now an array of layer objects, each with 'keys' and 'labels'
            const currentLayerData = keymap[currentLayer] || { keys: Array(9).fill(null), labels: Array(9).fill('') };

            // Helper to get the key/label for a specific flat index
            const getCellContent = (flatIndex) => {
                // Ensure flatIndex is within bounds for keymap data
                if (flatIndex < 0 || flatIndex >= currentLayerData.keys.length) {
                    return null;
                }

                const keyCombo = currentLayerData.keys[flatIndex];
                const keyLabel = currentLayerData.labels[flatIndex];
                
                if (keyCombo) {
                    // Find the description from presets if available
                    let description = keyLabel; // Default to label
                    for (const category in presets) {
                        const found = presets[category].find(p => p.combo === keyCombo);
                        if (found) {
                            description = found.description;
                            break;
                        }
                    }
                    // For macros, use the macro name as description
                    if (keyCombo.startsWith("MACRO_")) {
                        const macroNum = keyCombo.split('_')[1];
                        // If you want to show the actual macro name, you'd need to pass the macros array here
                        description = `Macro ${macroNum}`;
                    }
                    // Special handling for layer functions
                    if (keyCombo.startsWith("TO(") || keyCombo.startsWith("MO(") || keyCombo.startsWith("TG(")) {
                        description = keyCombo; // Show the function directly
                    }
                    // Special handling for NO_OP
                    if (keyCombo === "NO_OP") {
                        description = "No Operation";
                    }

                    return { combo: keyCombo, description: description };
                }
                return null;
            };

            return (
                <div className="flex flex-col items-center">
                    <div className="flex flex-wrap justify-center gap-2 mb-4"> {/* Use flex-wrap for responsiveness */}
                        {[...Array(numLayers)].map((_, index) => ( // Render buttons based on numLayers
                            <button
                                key={`layer-btn-${index}`}
                                onClick={() => setCurrentLayer(index)}
                                className={`px-4 py-2 rounded-lg font-semibold transition-colors duration-200
                                            ${currentLayer === index ? 'bg-red-600 text-white shadow-md' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}
                            >
                                Layer {index}
                            </button>
                        ))}
                        <button
                            onClick={clearCurrentLayer}
                            className="px-4 py-2 rounded-lg font-semibold bg-red-800 text-white hover:bg-red-700 transition-colors duration-200 shadow-md"
                            title="Clear all keys on the current layer"
                        >
                            Clear Current Layer
                        </button>
                    </div>
                    {/* Render keys based on physicalLayout */}
                    <div className="grid grid-cols-3 gap-4 mb-12 w-full max-w-md mx-auto">
                        {physicalLayout.map((layoutItem, gridIndex) => {
                            // If layoutItem is null or doesn't have a valid index, render an empty slot
                            if (layoutItem === null || typeof layoutItem.index === 'undefined' || layoutItem.index === null) {
                                return (
                                    <div
                                        key={`empty-${gridIndex}`}
                                        className="relative bg-zinc-900 rounded-xl p-4 h-32 flex flex-col items-center justify-center border-2 border-zinc-800 shadow-inner text-zinc-600 italic"
                                    >
                                        Empty Slot
                                    </div>
                                );
                            }

                            // Use the 'index' from physical_layout as the flat index for keymap data
                            const flatIndex = layoutItem.index; 
                            const cellContent = getCellContent(flatIndex);

                            return (
                                <div
                                    key={`cell-${flatIndex}`} /* Use flatIndex for key as it's the unique identifier for logical position */
                                    className={`relative bg-zinc-700 rounded-xl p-4 h-32 flex flex-col items-center justify-center border-2 border-zinc-600 shadow-md
                                                hover:border-red-500 transition-all duration-200 cursor-pointer
                                                ${selectedKeymapCell && selectedKeymapCell.index === flatIndex && selectedKeymapCell.layer === currentLayer ? 'border-blue-500 ring-2 ring-blue-500 bg-blue-900 bg-opacity-30' : ''}`}
                                    onDragOver={(e) => e.preventDefault()}
                                    onDrop={(e) => handleDrop(e, flatIndex)}
                                    draggable
                                    onDragStart={(e) => handleKeymapDragStart(e, cellContent, flatIndex)}
                                    onDragEnd={handleDragEnd}
                                    onClick={() => handleKeymapCellClick(flatIndex, currentLayer)}
                                >
                                    {cellContent ? (
                                        <>
                                            <span className="text-2xl font-bold text-red-300">{cellContent.combo}</span>
                                            <span className="text-sm text-zinc-400 text-center mt-1">{cellContent.description}</span>
                                        </>
                                    ) : (
                                        <span className="text-zinc-500">Drag & Drop Here</span>
                                    )}
                                    {cellContent && (
                                        <button
                                            onClick={(e) => { e.stopPropagation(); clearKeymapCell(flatIndex); }}
                                            className="absolute top-1 right-1 text-zinc-400 hover:text-red-500 text-sm p-1 rounded-full bg-zinc-600 hover:bg-zinc-500 transition-colors"
                                            title="Clear cell"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ShortcutPool component (formerly from src/components/ShortcutPool.js)
        const ShortcutPool = ({ shortcutPool, draggedShortcut, handleShortcutDragStart, handleDragEnd, selectedKeymapCell, handleShortcutClick }) => {
            const { useState, useEffect, useMemo } = React; // Added useMemo
            const [searchTerm, setSearchTerm] = useState('');
            // Initialize selectedCategory to the first key in shortcutPool
            const [selectedCategory, setSelectedCategory] = useState(Object.keys(shortcutPool)[0]);

            // Filter shortcuts based on selected category and search term
            const filteredShortcuts = useMemo(() => {
                if (!selectedCategory) return []; // No category selected yet

                const categoryShortcuts = shortcutPool[selectedCategory] || [];
                if (!searchTerm) return categoryShortcuts;

                const lowerCaseSearchTerm = searchTerm.toLowerCase();
                return categoryShortcuts.filter(shortcut =>
                    shortcut.combo.toLowerCase().includes(lowerCaseSearchTerm) ||
                    shortcut.description.toLowerCase().includes(lowerCaseSearchTerm)
                );
            }, [searchTerm, selectedCategory, shortcutPool]);

            return (
                <div className="flex flex-col md:flex-row w-full bg-zinc-800 rounded-xl shadow-lg border border-zinc-700 overflow-hidden">
                    {/* Left Sidebar for Categories */}
                    <div className="w-full md:w-1/4 bg-zinc-900 p-4 custom-scrollbar overflow-y-auto border-r border-zinc-700">
                        <h3 className="text-xl font-semibold text-red-300 mb-4">Categories</h3>
                        <ul className="space-y-2">
                            {Object.keys(shortcutPool).map(category => (
                                <li key={category}>
                                    <button
                                        onClick={() => setSelectedCategory(category)}
                                        className={`w-full text-left px-4 py-2 rounded-lg transition-colors duration-200
                                                    ${selectedCategory === category ? 'bg-red-600 text-white font-bold' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}
                                    >
                                        {category}
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>

                    {/* Right Main Content Area for Search and Shortcuts */}
                    <div className="flex-1 flex flex-col p-4">
                        {/* Search Bar */}
                        <div className="relative w-full mb-6">
                            <input
                                type="text"
                                placeholder="Search shortcuts..."
                                className="w-full p-3 pl-10 rounded-xl bg-zinc-700 text-white border border-zinc-600 focus:border-red-500 focus:ring-1 focus:ring-red-500 transition-all duration-200"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                            />
                            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-zinc-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd"></path></svg>
                        </div>

                        {/* Shortcuts Grid */}
                        <div className="flex-1 grid grid-cols-2 md:grid-cols-3 gap-4 custom-scrollbar overflow-y-auto pr-2">
                            {filteredShortcuts.length > 0 ? (
                                filteredShortcuts.map((shortcut, sIdx) => (
                                    <div
                                        key={`${selectedCategory}-${sIdx}`} // Ensure unique key
                                        className={`bg-zinc-600 rounded-lg p-3 flex flex-col items-center justify-center cursor-pointer text-center /* Changed cursor to pointer */
                                                    ${draggedShortcut === shortcut ? 'opacity-50 border-red-500 border-2' : 'border-2 border-zinc-600'}
                                                    ${selectedKeymapCell ? 'hover:bg-blue-700 hover:border-blue-400' : 'hover:bg-zinc-500 hover:border-red-400'} /* Conditional hover */
                                                    transition-all duration-200`}
                                        draggable
                                        onDragStart={(e) => handleShortcutDragStart(e, shortcut)}
                                        onDragEnd={handleDragEnd}
                                        onClick={() => handleShortcutClick(shortcut)} /* Added onClick */
                                    >
                                        <span className="font-medium text-lg">{shortcut.combo}</span>
                                        <span className="text-sm text-zinc-300">{shortcut.description}</span>
                                        {selectedKeymapCell && (
                                            <button
                                                onClick={(e) => { e.stopPropagation(); handleShortcutClick(shortcut); }}
                                                className="mt-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Assign
                                            </button>
                                        )}
                                    </div>
                                ))
                            ) : (
                                <p className="text-zinc-400 text-lg col-span-full text-center">No shortcuts found in "{selectedCategory}" matching "{searchTerm}".</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // MacroManagement component (formerly from src/components/MacroManagement.js)
        const MacroManagement = ({ macros, addMacro, editMacro, deleteMacro }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">MACRO MANAGEMENT</h1>
                    <button
                        onClick={addMacro}
                        className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold mb-8"
                    >
                        Add New Macro
                    </button>

                    {macros.length === 0 ? (
                        <p className="text-zinc-400 text-lg">No macros defined yet. Click "Add New Macro" to create one.</p>
                    ) : (
                        <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                            <h2 className="text-2xl font-bold text-red-300 mb-4">Defined Macros</h2>
                            <ul className="space-y-4">
                                {macros.map(macro => (
                                    <li key={macro.id} className="bg-zinc-600 rounded-lg p-4 flex flex-col sm:flex-row justify-between items-start sm:items-center shadow-md border border-zinc-500">
                                        <div>
                                            <p className="text-xl font-semibold text-white">{macro.name}</p>
                                            <p className="text-zinc-300 text-sm break-all">Sequence: "{macro.sequence}"</p>
                                        </div>
                                        <div className="flex space-x-3 mt-3 sm:mt-0">
                                            <button
                                                onClick={() => editMacro(macro.id)}
                                                className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Edit
                                            </button>
                                            <button
                                                onClick={() => deleteMacro(macro.id)}
                                                className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200"
                                            >
                                                Delete
                                            </button>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
            );
        };

        // PeripheralControls component (formerly from src/components/PeripheralControls.js)
        const PeripheralControls = ({ potentiometerConfig, setPotentiometerConfig }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">PERIPHERAL CONTROLS</h1>

                    <div className="w-full max-w-xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                        <h2 className="text-2xl font-bold text-red-300 mb-4">Potentiometer Configuration</h2>
                        <div className="space-y-4">
                            <div className="flex items-center justify-between">
                                <label htmlFor="potentiometer-enable" className="text-lg text-zinc-200">Enable Potentiometer:</label>
                                <input
                                    type="checkbox"
                                    id="potentiometer-enable"
                                    checked={potentiometerConfig.enabled}
                                    onChange={(e) => setPotentiometerConfig(prev => ({ ...prev, enabled: e.target.checked }))}
                                    className="form-checkbox h-6 w-6 text-red-600 rounded focus:ring-red-500"
                                />
                            </div>

                            {potentiometerConfig.enabled && (
                                <>
                                    <div className="flex items-center justify-between">
                                        <label htmlFor="potentiometer-pin" className="text-lg text-zinc-200">Analog Pin:</label>
                                        <input
                                            type="number"
                                            id="potentiometer-pin"
                                            value={potentiometerConfig.pin}
                                            onChange={(e) => setPotentiometerConfig(prev => ({ ...prev, pin: parseInt(e.target.value) || 0 }))}
                                            className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-24 text-white"
                                        />
                                    </div>

                                    <div className="flex items-center justify-between">
                                        <label htmlFor="potentiometer-function" className="text-lg text-zinc-200">Function:</label>
                                        <select
                                            id="potentiometer-function"
                                            value={potentiometerConfig.function}
                                            onChange={(e) => setPotentiometerConfig(prev => ({ ...prev, function: e.target.value }))}
                                            className="bg-zinc-800 border border-zinc-600 rounded-md p-2 text-white"
                                        >
                                            <option value="volume">Volume Control</option>
                                            <option value="scroll">Scroll</option>
                                            <option value="custom">Custom QMK Keycode</option>
                                        </select>
                                    </div>

                                    {potentiometerConfig.function === 'custom' && (
                                        <div className="flex items-center justify-between">
                                            <label htmlFor="custom-action" className="text-lg text-zinc-200">Custom QMK Keycode:</label>
                                            <input
                                                type="text"
                                                id="custom-action"
                                                value={potentiometerConfig.customAction}
                                                onChange={(e) => setPotentiometerConfig(prev => ({ ...prev, customAction: e.target.value }))}
                                                placeholder="e.g., KC_MPLY"
                                                className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-48 text-white"
                                            />
                                        </div>
                                    )}
                                </>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // SaveLoad component (formerly from src/components/SaveLoad.js)
        const SaveLoad = ({ saveProfile, loadProfile, exportKeymap, uploadToDevice, isConnected, handleConnectPico, handleGetFile, handleDeleteFile, logs, clearLogs, showLogDropdown, toggleLogDropdown }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full p-8"> {/* Added padding here */}
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">SAVE & LOAD PROFILE</h1>
                    <div className="flex flex-col space-y-4 w-full max-w-md">
                        <button
                            onClick={saveProfile}
                            className="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Save Profile to Browser
                        </button>
                        <button
                            onClick={loadProfile}
                            className="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Load Profile from Browser
                        </button>
                        <button
                            onClick={exportKeymap}
                            className="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Export Configuration as layers.json
                        </button>
                        <div className="bg-zinc-700 rounded-xl p-4 text-zinc-300 text-center text-sm border border-zinc-600">
                            To upload to Pico: Save the exported `layers.json` file, then drag and drop it onto your `CIRCUITPY` drive.
                        </div>
                        <h2 className="text-2xl font-bold text-red-300 mt-8 mb-4">Device Operations (Web Serial)</h2>
                        {!isConnected ? (
                            <button
                                onClick={handleConnectPico}
                                className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                            >
                                Connect to Device
                            </button>
                        ) : (
                            <>
                                <p className="text-green-400 text-center text-lg font-semibold">Connected to Pico!</p>
                                <button
                                    onClick={uploadToDevice}
                                    className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                                >
                                    Upload layers.json to Device
                                </button>
                                <button
                                    onClick={() => handleGetFile("layers.json")}
                                    className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                                >
                                    Check layers.json on Device
                                </button>
                                <button
                                    onClick={() => handleDeleteFile("layers.json")}
                                    className="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                                >
                                    Delete layers.json on Device
                                </button>
                            </>
                        )}

                        {/* Log Display Dropdown */}
                        <div className="mt-8 w-full">
                            <button
                                onClick={toggleLogDropdown}
                                className="w-full bg-zinc-600 hover:bg-zinc-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold flex justify-between items-center"
                            >
                                Show Device Log
                                <svg className={`w-5 h-5 transition-transform duration-200 ${showLogDropdown ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            {showLogDropdown && (
                                <div className="bg-zinc-700 rounded-xl p-4 mt-4 shadow-lg border border-zinc-600">
                                    <textarea
                                        readOnly
                                        value={logs.join('\n')}
                                        className="w-full h-48 bg-zinc-800 border border-zinc-600 rounded-md p-3 text-white font-mono text-sm resize-y custom-scrollbar"
                                        placeholder="Device log messages will appear here..."
                                    ></textarea>
                                    <button
                                        onClick={clearLogs}
                                        className="mt-3 bg-red-600 hover:bg-red-700 px-4 py-2 rounded-xl shadow-lg transition-colors duration-200 text-sm font-semibold w-full"
                                    >
                                        Clear Log
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // New component to display the physical layout JSON
        const PhysicalLayoutViewer = ({ physicalLayout }) => {
            const { useState, useEffect } = React;
            const [layoutJson, setLayoutJson] = useState('');

            useEffect(() => {
                try {
                    setLayoutJson(JSON.stringify(physicalLayout, null, 2));
                } catch (e) {
                    setLayoutJson("Error displaying layout JSON.");
                }
            }, [physicalLayout]);

            return (
                <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 mt-8">
                    <h2 className="text-2xl font-bold text-red-300 mb-4">Current Physical Layout (from Application State)</h2>
                    <p className="text-zinc-400 mb-2 text-sm">This shows the layout currently applied to the UI. To change it, paste a new configuration above that includes a "physical_layout" array.</p>
                    <textarea
                        readOnly
                        className="w-full h-64 bg-zinc-800 border border-zinc-600 rounded-md p-4 text-white font-mono text-sm resize-y custom-scrollbar"
                        value={layoutJson}
                    ></textarea>
                </div>
            );
        };

        // Settings component (formerly from src/components/Settings.js)
        const Settings = ({ jsonInput, setJsonInput, loadJsonFromTextArea, numLayers, setNumLayers, physicalLayout }) => {
            const { useState, useEffect } = React;
            return (
                <div className="flex flex-col items-center w-full p-8"> {/* Added padding here */}
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">SETTINGS</h1>
                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600">
                        <h2 className="text-2xl font-bold text-red-300 mb-4">Layer Configuration</h2>
                        <div className="flex items-center justify-between mb-6">
                            <label htmlFor="num-layers" className="text-lg text-zinc-200 mr-4">Number of Layers:</label>
                            <input
                                type="number"
                                id="num-layers"
                                value={numLayers}
                                onChange={(e) => {
                                    const value = parseInt(e.target.value);
                                    if (!isNaN(value)) {
                                        setNumLayers(Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, value)));
                                    }
                                }}
                                min={MIN_LAYERS}
                                max={MAX_LAYERS}
                                className="bg-zinc-800 border border-zinc-600 rounded-md p-2 w-24 text-white text-center"
                            />
                        </div>

                        <h2 className="text-2xl font-bold text-red-300 mb-4">Import JSON Configuration</h2>
                        <textarea
                            className="w-full h-64 bg-zinc-800 border border-zinc-600 rounded-md p-4 text-white font-mono text-sm resize-y"
                            placeholder="Paste your full Trkey configuration JSON here, including 'physical_layout' and 'layers'..."
                            value={jsonInput}
                            onChange={(e) => setJsonInput(e.target.value)}
                        ></textarea>
                        <button
                            onClick={loadJsonFromTextArea}
                            className="mt-4 bg-teal-600 hover:bg-teal-700 px-6 py-3 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold w-full"
                        >
                            Load JSON
                        </button>
                    </div>
                    {/* Add the PhysicalLayoutViewer component here */}
                    <PhysicalLayoutViewer physicalLayout={physicalLayout} />
                </div>
            );
        };

        // KeyTester component (formerly from src/components/KeyTester.js)
        const KeyTester = ({ activeTab }) => {
            const { useState, useEffect } = React;
            const [pressedKeys, setPressedKeys] = useState([]);
            const [modifierState, setModifierState] = useState({
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                metaKey: false, // Windows key or Command key on Mac
            });

            useEffect(() => {
                if (activeTab === 'keytester') {
                    const handleKeyDown = (e) => {
                        e.preventDefault(); // Prevent default browser actions for keys
                        setPressedKeys(prev => {
                            const newKey = { key: e.key, code: e.code, timestamp: Date.now() };
                            // Only add if not already present to avoid duplicates for held keys
                            if (!prev.some(k => k.code === e.code)) {
                                return [...prev, newKey];
                            }
                            return prev;
                        });
                        setModifierState({
                            ctrlKey: e.ctrlKey,
                            shiftKey: e.shiftKey,
                            altKey: e.altKey,
                            metaKey: e.metaKey,
                        });
                    };

                    const handleKeyUp = (e) => {
                        e.preventDefault();
                        setPressedKeys(prev => prev.filter(k => k.code !== e.code));
                        setModifierState({
                            ctrlKey: e.ctrlKey,
                            shiftKey: e.shiftKey,
                            altKey: e.altKey,
                            metaKey: e.metaKey,
                        });
                    };

                    window.addEventListener('keydown', handleKeyDown);
                    window.addEventListener('keyup', handleKeyUp);

                    return () => {
                        window.removeEventListener('keydown', handleKeyDown);
                        window.removeEventListener('keyup', handleKeyUp);
                    };
                } else {
                    setPressedKeys([]);
                    setModifierState({
                        ctrlKey: false,
                        shiftKey: false,
                        altKey: false,
                        metaKey: false,
                    });
                }
            }, [activeTab]);

            const clearPressedKeys = () => {
                setPressedKeys([]);
                setModifierState({
                    ctrlKey: false,
                    shiftKey: false,
                    altKey: false,
                    metaKey: false,
                });
            };

            return (
                <div className="flex flex-col items-center w-full p-8">
                    <h1 className="text-4xl font-extrabold text-red-400 mb-8">KEY TESTER</h1>
                    <p className="text-zinc-300 mb-6 text-lg text-center">Press any key on your keyboard to see its details and active modifiers.</p>

                    <div className="w-full max-w-2xl bg-zinc-700 rounded-xl p-6 shadow-lg border-2 border-zinc-600 min-h-[250px] flex flex-col items-center">
                        <div className="flex justify-center space-x-4 mb-6 w-full">
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.ctrlKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Ctrl</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.shiftKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Shift</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.altKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Alt</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-semibold transition-colors duration-200 ${modifierState.metaKey ? 'bg-blue-600 text-white' : 'bg-zinc-600 text-zinc-300'}`}>Meta (Win/Cmd)</span>
                        </div>

                        <div className="flex-1 flex flex-wrap items-center justify-center gap-4 w-full">
                            {pressedKeys.length === 0 ? (
                                <p className="text-zinc-400 text-xl">No keys pressed...</p>
                            ) : (
                                pressedKeys.map((keyInfo, index) => (
                                    <div
                                        key={keyInfo.code + '-' + keyInfo.timestamp}
                                        className="bg-zinc-600 rounded-lg p-4 shadow-md border border-zinc-500 flex flex-col items-center justify-center min-w-[120px] transform transition-transform duration-100 hover:scale-105"
                                    >
                                        <span className="text-xl font-bold text-red-300">{keyInfo.key === ' ' ? 'Space' : keyInfo.key === '' ? 'Unknown' : keyInfo.key}</span>
                                        <span className="text-sm text-zinc-400 mt-1">{keyInfo.code}</span>
                                    </div>
                                ))
                            )}
                        </div>
                        <button
                            onClick={clearPressedKeys}
                            className="mt-6 bg-red-600 hover:bg-red-700 px-6 py-2 rounded-xl shadow-lg transition-colors duration-200 text-lg font-semibold"
                        >
                            Clear Pressed Keys
                        </button>
                    </div>
                </div>
            );
        };


        // Main App component (formerly from src/App.js)
        function App() {
            const { useState, useEffect, useCallback } = React;

            // Web Serial state
            const [port, setPort] = useState(null);
            const [reader, setReader] = useState(null);
            const [writer, setWriter] = useState(null);
            const [isConnected, setIsConnected] = useState(false);
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();

            // Log state
            const [logs, setLogs] = useState([]);
            const [showLogDropdown, setShowLogDropdown] = useState(false);

            const addLog = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogs(prevLogs => [`[${timestamp}] [${type.toUpperCase()}] ${message}`, ...prevLogs].slice(0, 50)); // Keep last 50 logs
            };

            const clearLogs = () => {
                setLogs([]);
            };

            const toggleLogDropdown = () => {
                setShowLogDropdown(prev => !prev);
            };

            // Web Serial Utility Functions
            const connectPico = async () => {
                try {
                    addLog("Attempting to connect to Pico...", "info");
                    const selectedPort = await navigator.serial.requestPort();
                    await selectedPort.open({ baudRate: 115200 });
                    const newWriter = selectedPort.writable.getWriter();
                    const newReader = selectedPort.readable.getReader();

                    setPort(selectedPort);
                    setWriter(newWriter);
                    setReader(newReader);
                    setIsConnected(true);
                    setModalContent({
                        title: "Connection Successful",
                        message: "Successfully connected to Pico!"
                    });
                    addLog("Successfully connected to Pico!", "success");

                    // Listen for disconnect
                    selectedPort.addEventListener('disconnect', () => {
                        setIsConnected(false);
                        setPort(null);
                        setReader(null);
                        setWriter(null);
                        setModalContent({
                            title: "Disconnected",
                            message: "Pico disconnected."
                        });
                        addLog("Pico disconnected.", "warn");
                        setShowModal(true);
                    });

                } catch (error) {
                    setIsConnected(false);
                    setModalContent({
                        title: "Connection Failed",
                        message: "Failed to connect to Pico: " + error.message
                    });
                    addLog(`Failed to connect to Pico: ${error.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            // Send a command (LIST, DEL filename, etc.)
            const sendCommand = async (cmd) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot send command.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Sending command: ${cmd}`, "info");
                await writer.write(encoder.encode(cmd + "\n"));
            };

            // Read response until <END> or <EOF>
            const readResponse = async (until = "<END>") => {
                let out = "";
                while (true) {
                    const { value } = await reader.read();
                    if (!value) break;
                    const text = decoder.decode(value);
                    out += text;
                    if (out.includes(until)) break;
                }
                addLog(`Received response (until '${until}'):\n${out}`, "info");
                return out;
            };

            // Upload a file to Pico
            const putFile = async (file) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot upload file.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Initiating upload for ${file.name}...`, "info");
                await sendCommand("PUT " + file.name);
                await new Promise(r => setTimeout(r, 100));

                const buf = new Uint8Array(await file.arrayBuffer());
                const chunkSize = 256;
                for (let i = 0; i < buf.length; i += chunkSize) {
                    await writer.write(buf.slice(i, i + chunkSize));
                    await new Promise(r => setTimeout(r, 1));
                }
                await writer.write(encoder.encode("<EOF>"));
                addLog(`Uploaded ${file.name} chunks. Waiting for Pico confirmation.`, "info");
            };

            // Download file from Pico (modified to not trigger download, just return content)
            const getFile = async (filename) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot get file.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Initiating request for ${filename}...`, "info");
                await sendCommand("GET " + filename);
                const chunks = [];
                while (true) {
                    const { value } = await reader.read();
                    if (!value) break;
                    const view = new Uint8Array(value);
                    const text = decoder.decode(view);
                    if (text.includes("<EOF>")) {
                        chunks.push(view.slice(0, text.indexOf("<EOF>")));
                        break;
                    }
                    chunks.push(view);
                }
                const blob = new Blob(chunks);
                addLog(`Received content for ${filename}.`, "success");
                return blob; // Return blob to allow further processing (e.g., loading into textarea)
            };

            // Delete a file
            const deleteFile = async (fname) => {
                if (!writer) {
                    addLog("Not connected to Pico. Cannot delete file.", "error");
                    throw new Error("Not connected to Pico.");
                }
                addLog(`Attempting to delete ${fname}...`, "info");
                await sendCommand("DEL " + fname);
                const response = await readResponse();
                addLog(`Delete response for ${fname}: ${response}`, "info");
            };

            // State for the physical layout of the keys (e.g., 3x3 grid, or custom layout with nulls)
            const [physicalLayout, setPhysicalLayout] = useState(() => createDefaultPhysicalLayout());
            // DEBUG: Log when physicalLayout state changes in App
            useEffect(() => {
                console.log("App state - physicalLayout updated:", physicalLayout);
            }, [physicalLayout]);

            // New state for number of layers
            const [numLayers, setNumLayers] = useState(DEFAULT_LAYERS);

            // State for the keymap, initialized based on numLayers
            const [keymap, setKeymap] = useState(() => Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i)));
            
            // Effect to update keymap when numLayers changes
            useEffect(() => {
                setKeymap(prevKeymap => {
                    const newKeymap = Array(numLayers).fill().map((_, i) => {
                        if (prevKeymap[i]) {
                            return prevKeymap[i]; // Keep existing layer data
                        } else {
                            return createEmptyLayer(i); // Create new empty layer
                        }
                    });
                    return newKeymap;
                });

                // Adjust currentLayer if it's out of bounds
                setCurrentLayer(prevCurrentLayer => {
                    if (prevCurrentLayer >= numLayers) {
                        return numLayers > 0 ? numLayers - 1 : 0; // Go to last layer or 0 if no layers (min is 1 so never 0)
                    }
                    return prevCurrentLayer;
                });
                addLog(`Number of layers changed to ${numLayers}.`, "info");
            }, [numLayers]);


            const [shortcutPool, setShortcutPool] = useState(Object.fromEntries(Object.entries(presets).map(([k, v]) => [k, [...v]])));
            const [showModal, setShowModal] = useState(false);
            const [modalContent, setModalContent] = useState({ title: "", message: "" });
            const [draggedShortcut, setDraggedShortcut] = useState(null);
            const [activeTab, setActiveTab] = useState('keymap');
            const [jsonInput, setJsonInput] = useState('');
            const [currentLayer, setCurrentLayer] = useState(0); // New state for active layer in UI
            // New state for click-to-assign functionality
            const [selectedKeymapCell, setSelectedKeymapCell] = useState(null); // {index, layer} or null (index is the flat index)
            // New state for Web Serial API support
            const [webSerialSupported, setWebSerialSupported] = useState(false);

            const [macros, setMacros] = useState([
                { id: 1, name: "Macro 1", sequence: "Hello World!" }, // Renamed for consistency with Pico parsing
                { id: 2, name: "Macro 2", sequence: "control+alt+t" }, // Example macro
            ]);
            const [nextMacroId, setNextMacroId] = useState(3);

            const [potentiometerConfig, setPotentiometerConfig] = useState({
                enabled: false,
                pin: 34,
                function: 'volume',
                customAction: ''
            });

            // Load profile on component mount and check Web Serial API support
            useEffect(() => {
                loadProfile();
                setWebSerialSupported('serial' in navigator);
            }, []);

            // Handlers for drag and drop
            const handleDrop = (e, flatIndex) => { // Now takes flatIndex directly
                e.preventDefault();
                const data = e.dataTransfer.getData("text/plain");
                let droppedItem;

                try {
                    droppedItem = JSON.parse(data);
                } catch (error) {
                    console.error("Failed to parse dropped data:", error);
                    addLog("Failed to parse dropped data: " + error.message, "error");
                    setDraggedShortcut(null);
                    return;
                }

                const newKeymap = JSON.parse(JSON.stringify(keymap));

                if (droppedItem.isKeymapCell) {
                    const sourceFlatIndex = droppedItem.sourceFlatIndex;
                    const sourceLayer = droppedItem.sourceLayer;

                    if (sourceLayer === currentLayer) {
                        // Swap logic for same layer
                        const tempKey = newKeymap[currentLayer].keys[flatIndex];
                        const tempLabel = newKeymap[currentLayer].labels[flatIndex];

                        newKeymap[currentLayer].keys[flatIndex] = newKeymap[currentLayer].keys[sourceFlatIndex];
                        newKeymap[currentLayer].labels[flatIndex] = newKeymap[currentLayer].labels[sourceFlatIndex];

                        newKeymap[currentLayer].keys[sourceFlatIndex] = tempKey;
                        newKeymap[currentLayer].labels[sourceFlatIndex] = tempLabel;
                    } else {
                        // Copy from another layer
                        newKeymap[currentLayer].keys[flatIndex] = droppedItem.cell.combo;
                        newKeymap[currentLayer].labels[flatIndex] = droppedItem.cell.description;
                    }
                } else {
                    // Assign new shortcut
                    newKeymap[currentLayer].keys[flatIndex] = droppedItem.combo;
                    newKeymap[currentLayer].labels[flatIndex] = droppedItem.description;
                }

                setKeymap(newKeymap);
                setDraggedShortcut(null);
                setSelectedKeymapCell(null); // Clear any active cell selection after drag-drop
                addLog(`Key assigned to Layer ${currentLayer}, Index ${flatIndex}.`, "info");
            };


            const handleKeymapDragStart = (e, cellContent, flatIndex) => { // Now takes flatIndex directly
                // Pass the combo and description for dragging
                const dragData = JSON.stringify({ isKeymapCell: true, cell: cellContent, sourceFlatIndex: flatIndex, sourceLayer: currentLayer });
                e.dataTransfer.setData("text/plain", dragData);
                setSelectedKeymapCell(null); // Clear any active cell selection on drag start
            };

            const handleShortcutDragStart = (e, shortcut) => {
                e.dataTransfer.setData("text/plain", JSON.stringify(shortcut));
                setDraggedShortcut(shortcut);
                setSelectedKeymapCell(null); // Clear any active cell selection on drag start
            };

            const handleDragEnd = () => {
                setDraggedShortcut(null);
            };

            const clearKeymapCell = (flatIndex) => { // Now takes flatIndex directly
                const updatedKeymap = keymap.map((layer, lIdx) => {
                    if (lIdx === currentLayer) {
                        const newKeys = [...layer.keys];
                        const newLabels = [...layer.labels];
                        newKeys[flatIndex] = null; // Set key to null
                        newLabels[flatIndex] = ''; // Clear label
                        return { ...layer, keys: newKeys, labels: newLabels };
                    }
                    return layer;
                });
                setKeymap(updatedKeymap);
                setSelectedKeymapCell(null); // Clear selection if the cleared cell was selected
                addLog(`Keymap cell Layer ${currentLayer}, Index ${flatIndex} cleared.`, "info");
            };

            // New handler for clicking a keymap cell
            const handleKeymapCellClick = (flatIndex, layer) => { // Now takes flatIndex directly
                // If the clicked cell is already selected, deselect it
                if (selectedKeymapCell && selectedKeymapCell.index === flatIndex && selectedKeymapCell.layer === layer) {
                    setSelectedKeymapCell(null);
                    addLog(`Deselected keymap cell Layer ${layer}, Index ${flatIndex}.`, "info");
                } else {
                    // Otherwise, select this cell
                    setSelectedKeymapCell({ index: flatIndex, layer }); // Store index
                    addLog(`Selected keymap cell Layer ${layer}, Index ${flatIndex}.`, "info");
                }
            };

            // New handler for clicking a shortcut in the pool
            const handleShortcutClick = (shortcut) => {
                if (selectedKeymapCell) {
                    const { index, layer } = selectedKeymapCell; // Get index
                    const newKeymap = JSON.parse(JSON.stringify(keymap));
                    newKeymap[layer].keys[index] = shortcut.combo;
                    newKeymap[layer].labels[index] = shortcut.description; // Store description as label
                    setKeymap(newKeymap);
                    setSelectedKeymapCell(null); // Clear selection after assignment
                    addLog(`Assigned "${shortcut.combo}" to Layer ${layer}, Index ${index}.`, "info");
                } else {
                    // Optionally, you could show a modal or message if no cell is selected
                    setModalContent({
                        title: "No Keymap Cell Selected",
                        message: "Please click a keymap cell first to select it, then click a shortcut to assign it."
                    });
                    setShowModal(true);
                    addLog("Attempted to assign shortcut without selecting a keymap cell.", "warn");
                }
            };

            // New handler to clear all cells on the current layer
            const clearCurrentLayer = () => {
                setModalContent({
                    title: "Confirm Clear Layer",
                    message: `Are you sure you want to clear all keys on Layer ${currentLayer}? This action cannot be undone.`,
                    onConfirm: () => {
                        const updatedKeymap = keymap.map((layer, lIdx) =>
                            lIdx === currentLayer
                                ? { ...layer, keys: Array(9).fill(null), labels: Array(9).fill('') } // Clear keys and labels
                                : layer
                        );
                        setKeymap(updatedKeymap);
                        setSelectedKeymapCell(null); // Clear any active cell selection
                        setShowModal(false);
                        addLog(`All keys on Layer ${currentLayer} cleared.`, "info");
                    },
                    onCancel: () => {
                        setShowModal(false);
                        addLog(`Clear Layer ${currentLayer} cancelled.`, "info");
                    }
                });
                setShowModal(true);
            };


            // Profile Management
            const saveProfile = () => {
                const profileData = {
                    keymap: keymap, // Save the multi-layer keymap
                    physicalLayout: physicalLayout, // Save the current physical layout
                    potentiometerConfig: potentiometerConfig,
                    macros: macros,
                    numLayers: numLayers // Save the number of layers
                };
                localStorage.setItem("trkey_profile", JSON.stringify(profileData));
                setModalContent({
                    title: "Profile Saved",
                    message: "Profile saved to browser storage."
                });
                setShowModal(true);
                addLog("Profile saved to browser storage.", "info");
            };

            const loadProfile = () => {
                const saved = localStorage.getItem("trkey_profile");
                if (saved) {
                    const profileData = JSON.parse(saved);
                    
                    const loadedNumLayers = profileData.numLayers || DEFAULT_LAYERS;
                    const clampedNumLayers = Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, loadedNumLayers));
                    setNumLayers(clampedNumLayers);

                    // Re-initialize keymap based on loadedNumLayers (or clamped)
                    const newKeymap = Array(clampedNumLayers).fill().map((_, i) => {
                        if (profileData.keymap && profileData.keymap[i]) {
                            // Deep copy to ensure independence
                            return { ...profileData.keymap[i], 
                                keys: [...profileData.keymap[i].keys], 
                                labels: [...profileData.keymap[i].labels] 
                            };
                        } else {
                            return createEmptyLayer(i);
                        }
                    });
                    setKeymap(newKeymap);

                    // Load physical layout, or default if not found/invalid
                    if (profileData.physicalLayout && Array.isArray(profileData.physicalLayout)) {
                        setPhysicalLayout(profileData.physicalLayout);
                    } else {
                        setPhysicalLayout(createDefaultPhysicalLayout());
                    }

                    setPotentiometerConfig(profileData.potentiometerConfig || { enabled: false, pin: 34, function: 'volume', customAction: '' });
                    setMacros(profileData.macros || []);

                    // Adjust currentLayer if it's out of bounds after loading
                    setCurrentLayer(prevCurrentLayer => {
                        if (prevCurrentLayer >= clampedNumLayers) {
                            return clampedNumLayers > 0 ? clampedNumLayers - 1 : 0;
                        }
                        return prevCurrentLayer;
                    });

                    setModalContent({
                        title: "Profile Loaded",
                        message: "Profile loaded successfully."
                    });
                    addLog("Profile loaded from browser storage.", "info");
                } else {
                    setModalContent({
                        title: "No Profile Found",
                        message: "No saved profile found. Initializing with default layers and layout."
                    });
                    setKeymap(Array(DEFAULT_LAYERS).fill().map((_, i) => createEmptyLayer(i)));
                    setNumLayers(DEFAULT_LAYERS);
                    setPhysicalLayout(createDefaultPhysicalLayout()); // Also set default physical layout
                    addLog("No saved profile found in browser storage. Initialized with default layers and layout.", "info");
                }
                setShowModal(true);
            };

            // Export and Upload
            const exportKeymap = () => {
                // Transform the internal multi-layer keymap state to the Pico-friendly layers.json format
                const layersForExport = []; // Array of layer objects

                // Use the current numLayers for export
                keymap.slice(0, numLayers).forEach((layerData, lIdx) => {
                    // Ensure layerData has 'name', 'labels', 'keys'
                    const layerName = layerData.name || `Layer ${lIdx}`;
                    const keys = layerData.keys.map(key => key || ""); // Replace null with empty string
                    const labels = layerData.labels.map(label => label || ""); // Replace null with empty string

                    layersForExport.push({
                        name: layerName,
                        labels: labels,
                        keys: keys
                    });
                });

                const fullExportData = {
                    physical_layout: physicalLayout, // Include the physical layout
                    layers: layersForExport // Include the layers array
                };

                // Macros are typically added to the first layer in Pico's layers.json
                if (macros.length > 0) {
                    if (fullExportData.layers.length > 0) {
                         // Ensure macros are stored as {name: "Macro X", sequence: "..."}
                         fullExportData.layers[0].macros = macros.map(m => ({ name: m.name, sequence: m.sequence }));
                    }
                }

                const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "layers.json"; // Changed filename to layers.json
                a.click();
                setModalContent({
                    title: "Export Successful",
                    message: "Configuration exported as layers.json. Drag this file onto your CIRCUITPY drive."
                });
                setShowModal(true);
                addLog("Configuration exported as layers.json.", "info");
            };

            const uploadToDevice = async () => {
                try {
                    if (!webSerialSupported) {
                        setModalContent({
                            title: "Web Serial API Not Supported",
                            message: "Your browser does not support the Web Serial API. Please use a Chromium-based browser (e.g., Chrome, Edge) to upload to device."
                        });
                        setShowModal(true);
                        addLog("Web Serial API not supported.", "error");
                        return;
                    }

                    if (!isConnected) {
                        setModalContent({
                            title: "Not Connected",
                            message: "Please connect to your Pico device first."
                        });
                        setShowModal(true);
                        addLog("Not connected to Pico for upload.", "warn");
                        return;
                    }

                    // Transform the internal multi-layer keymap state to the Pico-friendly layers.json format
                    const layersForUpload = [];
                    // Use the current numLayers for upload
                    keymap.slice(0, numLayers).forEach((layerData, lIdx) => {
                        const layerName = layerData.name || `Layer ${lIdx}`;
                        const keys = layerData.keys.map(key => key || "");
                        const labels = layerData.labels.map(label => label || "");

                        layersForUpload.push({
                            name: layerName,
                            labels: labels,
                            keys: keys
                        });
                    });

                    const fullUploadData = {
                        physical_layout: physicalLayout, // Include the physical layout
                        layers: layersForUpload, // Include the layers array
                    };

                    // Add macros to the first layer for upload
                    if (macros.length > 0 && fullUploadData.layers.length > 0) {
                        fullUploadData.layers[0].macros = macros.map(m => ({ name: m.name, sequence: m.sequence }));
                    }

                    const json = JSON.stringify(fullUploadData);
                    const blob = new Blob([json], { type: "application/json" });
                    
                    // Create a File object from the Blob
                    const fileToUpload = new File([blob], "layers.json", { type: "application/json" });

                    setModalContent({
                        title: "Uploading...",
                        message: "Uploading layers.json to Pico. Please wait."
                    });
                    setShowModal(true);
                    addLog("Starting layers.json upload to Pico...", "info");

                    await putFile(fileToUpload); // Pass the File object
                    
                    setModalContent({
                        title: "Upload Successful",
                        message: "Configuration uploaded successfully!"
                    });
                    addLog("Configuration uploaded successfully!", "success");
                } catch (err) {
                    setModalContent({
                        title: "Upload Failed",
                        message: "Failed to upload: " + err.message
                    });
                    addLog(`Upload failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleConnectPico = async () => {
                await connectPico();
            };

            const handleGetFile = async (filename) => {
                try {
                    if (!isConnected) {
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device first." });
                        setShowModal(true);
                        addLog("Not connected to Pico for file check.", "warn");
                        return;
                    }
                    setModalContent({ title: "Checking...", message: `Checking ${filename} on Pico. Please wait.` });
                    setShowModal(true);
                    addLog(`Starting check of ${filename} on Pico...`, "info");
                    const blob = await getFile(filename); // getFile now just returns blob
                    const text = await blob.text();
                    
                    // Attempt to pretty-print if it's JSON
                    try {
                        const parsed = JSON.parse(text);
                        setJsonInput(JSON.stringify(parsed, null, 2));
                    } catch (parseError) {
                        setJsonInput(text); // If not JSON, just set the raw text
                    }
                    
                    setActiveTab('settings'); // Switch to settings tab to show the content
                    setModalContent({ title: "Check Successful", message: `${filename} content loaded into settings tab.` });
                    addLog(`${filename} content loaded into settings tab.`, "success");
                } catch (err) { // Corrected syntax: removed '=>'
                    setModalContent({ title: "Check Failed", message: `Failed to check ${filename}: ${err.message}` });
                    addLog(`Check of ${filename} failed: ${err.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            const handleDeleteFile = async (filename) => {
                try {
                    if (!isConnected) {
                        setModalContent({ title: "Not Connected", message: "Please connect to your Pico device first." });
                        setShowModal(true);
                        addLog("Not connected to Pico for file deletion.", "warn");
                        return;
                    }
                    setModalContent({
                        title: "Confirm Delete",
                        message: `Are you sure you want to delete ${filename} from Pico?`,
                        onConfirm: async () => {
                            setShowModal(false); // Close confirmation modal
                            setModalContent({ title: "Deleting...", message: `Deleting ${filename} from Pico. Please wait.` });
                            setShowModal(true);
                            addLog(`Confirming deletion of ${filename}...`, "info");
                            await deleteFile(filename); // deleteFile now handles its own response logging
                            setModalContent({ title: "Delete Successful", message: `${filename} deleted.` });
                            addLog(`${filename} deleted successfully.`, "success");
                            setShowModal(true);
                        },
                        onCancel: () => {
                            setShowModal(false);
                            addLog(`Deletion of ${filename} cancelled.`, "info");
                        }
                    });
                    setShowModal(true);
                } catch (err) {
                    setModalContent({ title: "Delete Failed", message: `Failed to delete ${filename}: ${err.message}` });
                    addLog(`Deletion of ${filename} failed: ${err.message}`, "error");
                    setShowModal(true);
                }
            };


            // JSON Import
            const loadJsonFromTextArea = () => {
                try {
                    const parsedJson = JSON.parse(jsonInput);
                    console.log("Parsed JSON from text area:", parsedJson); // DEBUG: Log full parsed JSON

                    // Expecting a root object with 'physical_layout' and 'layers' keys
                    if (typeof parsedJson === 'object' && parsedJson !== null && Array.isArray(parsedJson.layers)) {
                        // Load layers
                        const loadedLayers = parsedJson.layers;
                        const loadedNumLayers = Math.max(MIN_LAYERS, Math.min(MAX_LAYERS, loadedLayers.length));
                        setNumLayers(loadedNumLayers); // Update the numLayers state

                        const newKeymap = Array(loadedNumLayers).fill().map((_, layerIdx) => {
                            if (loadedLayers[layerIdx]) {
                                return {
                                    name: loadedLayers[layerIdx].name || `Layer ${layerIdx}`,
                                    labels: Array.isArray(loadedLayers[layerIdx].labels) && loadedLayers[layerIdx].labels.length === 9
                                        ? [...loadedLayers[layerIdx].labels]
                                        : Array(9).fill(''), // Ensure 9 elements
                                    keys: Array.isArray(loadedLayers[layerIdx].keys) && loadedLayers[layerIdx].keys.length === 9
                                        ? [...loadedLayers[layerIdx].keys]
                                        : Array(9).fill(null), // Ensure 9 elements
                                    macros: loadedLayers[layerIdx].macros || []
                                };
                            } else {
                                return createEmptyLayer(layerIdx);
                            }
                        });
                        setKeymap(newKeymap);
                        console.log("App state - keymap after loading:", newKeymap); // DEBUG: Log keymap state

                        // Load physical_layout
                        if (Array.isArray(parsedJson.physical_layout)) {
                            // Validate physical_layout: ensure it contains objects with index, row, col, or null
                            const validatedPhysicalLayout = parsedJson.physical_layout.map(item => {
                                if (item === null || (typeof item === 'object' && item !== null && 'index' in item && 'row' in item && 'col' in item)) {
                                    return item;
                                }
                                return null; // Invalid items become null
                            });
                            setPhysicalLayout(validatedPhysicalLayout);
                            console.log("App state - physicalLayout after loading:", validatedPhysicalLayout); // DEBUG: Log physicalLayout state
                            addLog(`Physical layout loaded from JSON. Detected ${validatedPhysicalLayout.filter(i => i !== null).length} active key positions.`, "info");
                        } else {
                            const defaultLayout = createDefaultPhysicalLayout();
                            setPhysicalLayout(defaultLayout); // Reset to default if not found or invalid
                            console.log("App state - physicalLayout defaulted:", defaultLayout); // DEBUG: Log default layout
                            addLog("No valid 'physical_layout' found in JSON, defaulting to 3x3 layout.", "warn");
                        }

                        let loadedMacros = [];
                        let maxMacroId = 0;

                        // Consolidate macros from all loaded layers (though Pico expects them on layer 0)
                        parsedJson.layers.forEach(layerData => { // Iterate through parsedJson.layers
                            if (layerData.macros && Array.isArray(layerData.macros)) {
                                const newMacrosForLayer = layerData.macros.map((m) => {
                                    // Assign a new, unique ID for internal React state if needed, but keep original if existing
                                    const id = m.id || nextMacroId + loadedMacros.length;
                                    maxMacroId = Math.max(maxMacroId, id);
                                    return { id: id, name: m.name, sequence: m.sequence };
                                });
                                loadedMacros = [...loadedMacros, ...newMacrosForLayer];
                            }
                        });
                        
                        setMacros(loadedMacros);
                        setNextMacroId(maxMacroId + 1); // Update nextMacroId based on loaded macros

                        // Potentiometer config is not part of Pico's layers.json, so reset or keep default
                        setPotentiometerConfig({ enabled: false, pin: 34, function: 'volume', customAction: '' });

                        setCurrentLayer(prevCurrentLayer => {
                            if (prevCurrentLayer >= loadedNumLayers) {
                                return loadedNumLayers > 0 ? loadedNumLayers - 1 : 0;
                            }
                            return prevCurrentLayer;
                        });


                        setModalContent({
                            title: "JSON Loaded",
                            message: "Configuration loaded from text area successfully (layers.json format)."
                        });
                        addLog("Configuration loaded from text area successfully.", "success");
                    } else {
                        setModalContent({
                            title: "Invalid JSON",
                            message: "The pasted JSON does not contain a valid configuration. Expected a root object with 'physical_layout' (optional) and a 'layers' array."
                        });
                        addLog("Invalid JSON structure for layers.json.", "error");
                    }
                } catch (error) {
                    setModalContent({
                        title: "JSON Parsing Error",
                        message: "Failed to parse JSON: " + error.message
                    });
                    addLog(`JSON parsing error: ${error.message}`, "error");
                } finally {
                    setShowModal(true);
                }
            };

            // Macro functions
            const addMacro = () => {
                const name = prompt("Enter macro name (e.g., Macro 1):");
                if (!name) {
                    addLog("Macro creation cancelled (no name provided).", "info");
                    return;
                }
                const sequence = prompt("Enter macro sequence (e.g., 'Hello World!'):");
                if (sequence) {
                    setMacros(prev => [...prev, { id: nextMacroId, name, sequence }]);
                    setNextMacroId(prev => prev + 1);
                    addLog(`Macro "${name}" added.`, "info");
                } else {
                    addLog("Macro creation cancelled (no sequence provided).", "info");
                }
            };

            const editMacro = (id) => {
                const macroToEdit = macros.find(m => m.id === id);
                if (!macroToEdit) {
                    addLog(`Attempted to edit non-existent macro with ID: ${id}.`, "warn");
                    return;
                }

                const newName = prompt(`Edit name for "${macroToEdit.name}":`, macroToEdit.name);
                if (newName === null) {
                    addLog(`Edit for macro "${macroToEdit.name}" cancelled (name).`, "info");
                    return;
                }

                const newSequence = prompt(`Edit sequence for "${macroToEdit.name}":`, macroToEdit.sequence);
                if (newSequence === null) {
                    addLog(`Edit for macro "${macroToEdit.name}" cancelled (sequence).`, "info");
                    return;
                }

                setMacros(prev => prev.map(m =>
                    m.id === id ? { ...m, name: newName, sequence: newSequence } : m
                ));
                addLog(`Macro "${macroToEdit.name}" (ID: ${id}) updated.`, "info");
            };

            const deleteMacro = (id) => {
                setModalContent({
                    title: "Confirm Delete",
                    message: "Are you sure you want to delete this macro?",
                    onConfirm: () => {
                        setMacros(prev => prev.filter(m => m.id !== id));
                        setShowModal(false);
                        addLog(`Macro with ID: ${id} deleted.`, "info");
                    },
                    onCancel: () => {
                        setShowModal(false);
                        addLog(`Deletion of macro with ID: ${id} cancelled.`, "info");
                    }
                });
                setShowModal(true);
            };

            return (
                <div className="min-h-screen bg-zinc-800 text-white flex font-inter">
                    {/* Sidebar */}
                    <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />

                    {/* Main Content Area */}
                    <div className="flex-1 flex flex-col p-4 overflow-auto"> {/* Adjusted padding for overall content */}
                         {/* Web Serial Status Indicator */}
                        <div className="flex justify-end mb-4">
                            <span className={`text-sm px-3 py-1 rounded-full ${webSerialSupported ? 'bg-green-600' : 'bg-red-600'} text-white`}>
                                Web Serial: {webSerialSupported ? 'Supported' : 'Not Supported'}
                            </span>
                        </div>

                        {activeTab === 'keymap' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for keymap tab content */}
                                <h1 className="text-4xl font-extrabold text-red-400 mb-4">KEYMAP CONFIGURATION</h1>
                                {/* Visual Layer Indicator */}
                                <h2 className="text-2xl font-bold text-zinc-300 mb-8">Currently Viewing: Layer {currentLayer}</h2>
                                <KeymapGrid
                                    keymap={keymap}
                                    handleDrop={handleDrop}
                                    handleKeymapDragStart={handleKeymapDragStart}
                                    handleDragEnd={handleDragEnd}
                                    clearKeymapCell={clearKeymapCell}
                                    currentLayer={currentLayer} // Pass currentLayer
                                    setCurrentLayer={setCurrentLayer} // Pass setter for layer buttons
                                    selectedKeymapCell={selectedKeymapCell} /* New prop */
                                    handleKeymapCellClick={handleKeymapCellClick} /* New prop */
                                    clearCurrentLayer={clearCurrentLayer} /* New prop */
                                    numLayers={numLayers} /* Pass numLayers to KeymapGrid */
                                    physicalLayout={physicalLayout} /* Pass physicalLayout to KeymapGrid */
                                />
                                <h2 className="text-3xl font-bold text-red-400 mb-6">SHORTCUTS</h2>
                                <ShortcutPool
                                    shortcutPool={shortcutPool}
                                    draggedShortcut={draggedShortcut}
                                    handleShortcutDragStart={handleShortcutDragStart}
                                    handleDragEnd={handleDragEnd}
                                    selectedKeymapCell={selectedKeymapCell} /* New prop */
                                    handleShortcutClick={handleShortcutClick} /* New prop */
                                />
                            </div>
                        )}

                        {activeTab === 'macros' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for macros tab content */}
                                <MacroManagement
                                    macros={macros}
                                    addMacro={addMacro}
                                    editMacro={editMacro}
                                    deleteMacro={deleteMacro}
                                />
                            </div>
                        )}

                        {activeTab === 'controls' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for controls tab content */}
                                <PeripheralControls
                                    potentiometerConfig={potentiometerConfig}
                                    setPotentiometerConfig={setPotentiometerConfig}
                                />
                            </div>
                        )}

                        {activeTab === 'save-load' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for save-load tab content */}
                                <SaveLoad
                                    saveProfile={saveProfile}
                                    loadProfile={loadProfile}
                                    exportKeymap={exportKeymap}
                                    uploadToDevice={uploadToDevice}
                                    isConnected={isConnected} /* New prop */
                                    handleConnectPico={handleConnectPico} /* New prop */
                                    handleGetFile={handleGetFile} /* Modified prop */
                                    handleDeleteFile={handleDeleteFile} /* New prop */
                                    logs={logs} /* New prop */
                                    clearLogs={clearLogs} /* New prop */
                                    showLogDropdown={showLogDropdown} /* New prop */
                                    toggleLogDropdown={toggleLogDropdown} /* New prop */
                                />
                            </div>
                        )}

                        {activeTab === 'settings' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for settings tab content */}
                                <Settings
                                    jsonInput={jsonInput}
                                    setJsonInput={setJsonInput}
                                    loadJsonFromTextArea={loadJsonFromTextArea}
                                    numLayers={numLayers} /* Pass numLayers */
                                    setNumLayers={setNumLayers} /* Pass setNumLayers */
                                    physicalLayout={physicalLayout} /* Pass physicalLayout to Settings */
                                />
                            </div>
                        )}

                        {activeTab === 'keytester' && (
                            <div className="p-4 bg-zinc-800 rounded-xl shadow-lg border border-zinc-700"> {/* Added container for keytester tab content */}\
                                <KeyTester activeTab={activeTab} />
                            </div>
                        )}
                    </div>

                    {/* Modals */}
                    <Modal
                        show={showModal && !modalContent.onConfirm}
                        title={modalContent.title}
                        message={modalContent.message}
                        onClose={() => setShowModal(false)}
                    />
                    <ConfirmationModal
                        show={showModal && modalContent.onConfirm}
                        title={modalContent.title}
                        message={modalContent.message}
                        onConfirm={modalContent.onConfirm}
                        onCancel={modalContent.onCancel}
                    />
                </div>
            );
        }

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
