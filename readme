Perfect ‚Äî let‚Äôs pull everything together into a **single, full developer documentation** for your macropad firmware. This will serve as a reference for you, your contributors, and your web devs (Trkey Mapper integration). It covers **architecture, JSON format, HID pipeline, OLED, WebSerial, and software layer switching**.

---

# ‚öôÔ∏è Trkey Macropad Firmware Documentation

This document describes how the **Trkey macropad firmware** works internally, how it integrates with **Trkey Mapper** via WebSerial, and where developers can extend or customize it.

---

## üìÇ Firmware Files

* **`code.py`** ‚Üí main firmware (handles keys, OLED, HID, layers).
* **`webserial_fs.py`** ‚Üí USB CDC file server for Trkey Mapper.
* **`layers.json`** ‚Üí keymap definition uploaded by the user.

All three files must be present on the **CIRCUITPY** drive.

---

## 1. Layers & JSON

The firmware loads `layers.json` at startup and whenever the user sends a `RELOAD` command via USB.

### Example `layers.json`

```json
{
  "layers": [
    {
      "name": "Default",
      "labels": ["A", "B", "C", "Copy", "Paste", "Mute", "Next", "Prev", "Vol+"],
      "keys":   ["A", "B", "C", "CONTROL_C", "CONTROL_V", "MUTE", "MEDIA_NEXT", "MEDIA_PREVIOUS", "VOLUME_UP"]
    },
    {
      "name": "Nav",
      "labels": ["‚Üê", "‚Üí", "‚Üë", "‚Üì", "TO(0)", "MO(2)", "TT(2)", "DF(1)", " "],
      "keys":   ["LEFT_ARROW", "RIGHT_ARROW", "UP_ARROW", "DOWN_ARROW", "TO(0)", "MO(2)", "TT(2)", "DF(1)", "NO_OP"]
    },
    {
      "name": "Gaming",
      "labels": ["W", "A", "S", "D", " ", " ", " ", " ", " "],
      "keys":   ["W", "A", "S", "D", "SPACE", "NO_OP", "NO_OP", "NO_OP", "NO_OP"]
    }
  ]
}
```

### JSON Rules

* Each layer has `name`, `labels[]`, and `keys[]`.
* Length of `labels[]` and `keys[]` must match.
* Keys may be:

  * Standard HID names (`A`, `B`, `C`, `ENTER`).
  * Combos (`CONTROL_C`, `CONTROL_V`).
  * Media keys (`MUTE`, `PLAY_PAUSE`, `VOLUME_UP`).
  * Layer commands (`TO(x)`, `MO(x)`, `TT(x)`, `DF(x)`).
  * `NO_OP` for ‚Äúempty‚Äù.

---

## 2. Layer Switching

Firmware supports **software-based layer switching**:

| Command | Behavior                                           |
| ------- | -------------------------------------------------- |
| `TO(x)` | Switch permanently to layer `x`.                   |
| `MO(x)` | Momentary layer switch (active while key is held). |
| `TT(x)` | Toggle layer `x` on/off.                           |
| `DF(x)` | Set default layer to `x` (persists until next DF). |

Internally, the firmware maintains a **layer stack**.

* `get_current_layer()` = top of the stack.
* `DF(x)` resets the stack to `[x]`.
* `MO(x)` pushes/pops layers on press/release.

---

## 3. Key Processing Pipeline

When a button is pressed:

```python
keyname = layers[current_layer]["keys"][i]
send_key(keyname)
```

### `send_key()` behavior

1. **Layer switching** (`TO`, `MO`, `TT`, `DF`) handled first.
2. **Combos** (`CONTROL_C`, etc.) sent via `keycode_map`.
3. **Media keys** (`MUTE`, etc.) sent via `consumer_map`.
4. **Regular HID key** (e.g., `"A"`, `"ENTER"`) ‚Üí mapped via `adafruit_hid.keycode.Keycode`.
5. **NO\_OP** ‚Üí ignored.

---

## 4. HID Devices

* `Keyboard(usb_hid.devices)` ‚Üí sends keycodes.
* `ConsumerControl(usb_hid.devices)` ‚Üí sends media controls.

---

## 5. Button Matrix

* Pins `GP2‚ÄìGP10` ‚Üí mapped to 9 keys (3√ó3 grid).
* Button index = array index in `keys[]`/`labels[]`.
* No firmware-side remapping; wiring must match JSON.

---

## 6. Key Repeat

* Each button tracks:

  * `repeat_active[i]`
  * `repeat_start[i]`
  * `repeat_last[i]`
* Behavior:

  * Delay before repeat: **0.4s**
  * Repeat rate: **0.05s**

---

## 7. OLED Display

* 128√ó64 SSD1306 via I¬≤C (GP16 = SDA, GP17 = SCL).
* Shows:

  * **Active layer name** (`Layer: Default (1/3)`).
  * **Labels** for each key in 3√ó3 grid.
  * Pressed key highlighted in **green** for 0.3s.

Grid is **auto-calculated**; no `physical_layout` support needed.

---

## 8. WebSerial File Server

Trkey Mapper communicates with the firmware using a USB CDC protocol provided by **`webserial_fs.py`**.

| Command      | Action                                 |
| ------------ | -------------------------------------- |
| `LIST`       | List files in root.                    |
| `DEL <file>` | Delete file.                           |
| `PUT <file>` | Upload file (terminated with `<EOF>`). |
| `GET <file>` | Download file.                         |
| `RELOAD`     | Reload `layers.json` and update OLED.  |

This is how **Trkey Mapper** uploads new `layers.json` or firmware updates.

---

## 9. Extension Points

Developers can extend firmware in several ways:

### üîπ Macros

Add macro support to `layers.json`:

```json
"keys": ["MACRO_1"],
"macros": [{ "name": "Sig", "sequence": "Best,\nTrkey Dev" }]
```

Extend `send_key()`:

```python
if keyname.startswith("MACRO_"):
    idx = int(keyname.split("_")[1]) - 1
    sequence = layers[0]["macros"][idx]["sequence"]
    type_text(sequence)
```

### üîπ Dynamic Pin Mapping

Currently, pins GP2‚ÄìGP10 are fixed.
Could load pin mapping from `layers.json` or a `config.json`.

### üîπ Advanced Layer Switching

Already supports `TO`, `MO`, `TT`, `DF`.
Could add:

* `LT(x, KC)` ‚Üí Layer-Tap.
* `TG(x)` ‚Üí Toggle layer shortcut.
* Combos or tap/hold detection.

---

## üîë Summary for Developers

* Layers are defined in `layers.json`.
* OLED shows current layer + labels.
* HID events handled via `send_key()`.
* Layer switching supports `TO`, `MO`, `TT`, `DF`.
* Trkey Mapper talks to firmware via `webserial_fs.py`.
* Developers can extend with macros, dynamic pin maps, or QMK-style features.

---

‚ö° With this doc, any developer can:

1. Build their own **macropad/keyboard firmware** on top of Trkey.
2. Extend features while staying compatible with **Trkey Mapper**.
3. Contribute back macros, layer logic, or UI upgrades.

---

üëâ Do you also want me to package this doc into a **GitHub-ready README.md** (with headings, code formatting, emoji, etc.) so it‚Äôs easy for devs to read and copy?
